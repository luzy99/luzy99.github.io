{"posts":[{"title":"2021复旦机试回顾","text":"2021年复旦大学计算机专业预推免机试题，一共3道题，都比较常规，主要考察动态规划。 第一题 将 n 个正整数存放于一个一维数组中，编写一个程序，将数组中所有的奇数存放于所有的偶数之前，要求尽可能少用临时存储单元并使时间复杂度达到 O(n)。输入：一维数组；输出：符合要求的一维数组。 解题思路使用类似快排的思想，定义前后2个指针，前指针向后移动直到指向一个偶数；后指针向前移动直到指向一个奇数，然后交换这2个数的位置。然后继续移动2个指针直到相遇。由于2个指针一共只需遍历一遍数组，所以时间复杂度是O(n)，同时数字是原地交换的没有使用额外空间。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 将 n 个正整数存放于一个一维数组中，编写一个程序，将数组中所有的奇数存放于所有的偶数之前， * 要求尽可能少用临时存储单元并使时间复杂度达到 O(n)。 * 输入：一维数组；输出：符合要求的一维数组。 **/#include &lt;bits/stdc++.h&gt;using namespace std;bool is_odd(int x){ return x % 2 == 1;}int main(){ int a; vector&lt;int&gt; nums; while (cin &gt;&gt; a) { nums.push_back(a); } int n = nums.size(); int l = 0; int r = n - 1; while (l &lt; r) { while (l &lt; r &amp;&amp; is_odd(nums[l])) // 从左到右遍历，直到一个偶数 { l++; } while (l &lt; r &amp;&amp; !is_odd(nums[r])) // 从右到左遍历，直到一个奇数 { r--; } if (l &lt; r){ swap(nums[l++], nums[r++]); // 原地交换两数 } } for(auto&amp; i:nums){ cout&lt;&lt;i&lt;&lt;&quot; &quot;; }} 测试用例 1234# in1 2 3 4 5 6 7# out1 7 3 5 4 6 2 1234# in2 4 6# out2 4 6 1234# in4 6 8 1 5# out5 1 8 6 4 1234# in&lt;空&gt;# out&lt;空&gt; 第二题 给定 n 个小区之间的交通图， 并用二维数组 A[n][n]表示，即若小区 i 与小区 j 之间有路，则 A[i][j]表示这条路的长度。现计划在这 n 个小区中选定一个小区建一所医院，使距离医院最远的小区到医院的路程尽可能缩短。编写一个程序解决上述问题。输入：二维数组；输出：建医院的小区。 解题思路本题要先以每个点为起点，找到到达其他点的最短路径，算出到达最远点的距离。然后选出最远点距离最短的那个点。所以本题是一个多源最短路径问题，我采用了Floyd 算法，用的是动态规划的思想，如果顶点i和j之间存在一条经过k点的路径，能得到一条更短的路径，则可以将 k 作为其最短路径的中间点，更新最短路径长度。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 给定 n 个小区之间的交通图， 并用二维数组 A[n][n]表示，即若小区 i 与小区 j 之间有路， * 则 A[i][j]表示这条路的长度。现计划在这 n 个小区中选定一个小区建一所医院，使距离医院 * 最远的小区到医院的路程尽可能缩短。编写一个程序解决上述问题。 * 输入：二维数组；输出：建医院的小区。 **/#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; // n 个城市 cin &gt;&gt; n; // 每2个城市间的最短路径。初始：直达路长度 或 无穷远 vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, INT_MAX)); // 输入 int tmp; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; tmp; if (i == j) // 到自身的距离为0 { dist[i][j] = 0; continue; } if (tmp &gt; 0) dist[i][j] = tmp; } } // 用 Floyd 算法，求每2个点之间的最短路 for (int k = 0; k &lt; n; k++) // 中间点k { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { // 需要保证k到两点均存在通路 if (dist[i][k] &lt; INT_MAX &amp;&amp; dist[k][j] &lt; INT_MAX &amp;&amp; (dist[i][k] + dist[k][j] &lt; dist[i][j])) dist[i][j] = dist[i][k] + dist[k][j]; } } } int min_dis = INT_MAX; // 路径的最小值 int city=0; // 所选城市编号 for(int i=0;i&lt;n;i++){ // 假设以每个城市作为中心点，计算其他城市到 i 点最远的距离 int max_dis_to_i=0; // 到 i 点最远的距离 for(int j=0;j&lt;n;j++){ if(i==j)continue; max_dis_to_i=max(max_dis_to_i,dist[i][j]); } if(max_dis_to_i&lt;min_dis){ min_dis=max_dis_to_i; city=i; } } cout&lt;&lt;city;} 测试用例 1234567# in30 1 21 0 32 3 0# out0 1234567# in (0,1间没路)30 0 20 0 32 3 0# out2 12345678# in40 7 2 57 0 0 22 0 0 15 2 1 0# out2 第三题 给定一个长为 n 的序列， 其中序列中的元素都是 0～9 之间的整数。 现在要从序列的第一个位置走到最后一个位置，每次要么往后走一步，要么走到下一个与当前位置元素相同的位置， 编写一个程序求所需要的最少步数， 要求时间复杂度 O(n)。输入： 整数序列；输出： 最少步数。 解题思路本题我采用了动态规划的思路，假设$dp[i]$表示从位置0走到位置i的最少步数，$last[i]$表示i位置的数上一次出现的位置，由于每一步有2种选择，那么可以写出递推式$dp[i]=\\min(dp[i-1]+1,dp[last[i]]+1)$。最终答案即为$dp[n-1]$. 所以问题就转化为求解$last[]$数组，由于本题规定只有0~9之间的数字，所以不妨定义一个长度为10的滚动数组$digit_last[]$记录每个数字上次出现的位置，这样只需遍历一遍原始数组，就能构造出$last[]$. 总体而言，构造$last[]$数组时间复杂度为O(n)，求解dp的复杂度同样是O(n)，所以总体复杂度为O(n). 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 给定一个长为 n 的序列， 其中序列中的元素都是 0～9 之间的整数。 现在要从序列的第一个位置走到最后一个位置，每次要么往后走一步，要么走到下一个与当前位置元素相同的位置， 编写一个程序求所需要的最少步数， 要求时间复杂度 O(n)。 * 输入： 整数序列；输出： 最少步数。 **/#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int a; vector&lt;int&gt; nums; while (cin &gt;&gt; a) { nums.push_back(a); } int n = nums.size(); if (n == 0) { cout &lt;&lt; 0; return 0; } vector&lt;int&gt; digit_last(10, -1); // 记录每个*数字*上一次出现的位置 vector&lt;int&gt; last(n, -1); // 记录与该*位置*数字相同的上一个位置 // 构造last[]数组 for (int i = 0; i &lt; n; i++) { last[i] = digit_last[nums[i]]; digit_last[nums[i]] = i; } vector&lt;int&gt; dp(n); dp[0] = 0; for (int i = 1; i &lt; n; i++) { dp[i] = dp[i - 1] + 1; // 往后走一步 if (last[i] != -1) // 如果可以跳跃到此处 { dp[i] = min(dp[i], dp[last[i]] + 1); // 2种走法的最小值 } } cout &lt;&lt; dp[n - 1];} 测试用例 1234567# in0 1 0 3 4 1# out2# 解释：0-&gt;1-&gt;1 123456# in0 1 2 3 4 5# out5# 解释：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5 123456# in9 8 9 5 9 2 5 1# out4# 解释：9-&gt;9-&gt;5-&gt;5-&gt;1 1234# in&lt;空&gt;# out0","link":"/posts/2309874471/"},{"title":"Ajax编程应用及Nginx部署","text":"Ajax异步请求 前后端分离 发送异步请求获取接口数据（Vue/axios） 请求跨域问题@CrossOrigin 部署服务器 前端部署：nginx 后端接口服务，nohup java -jar xxx.jar &amp; Ajax特点 允许在同一页面中多次发送请求，并动态加载服务器数据至页面中 可以有效地避免页面的频繁刷新 Ajax工作原理 Axios请求示例 GET 12345678910111213141516171819axios.get('/user?ID=12345').then(function (response) {console.log(response);}).catch(function (error) {console.log(error);});axios.get('/user', {params: {ID: 12345}}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);}); POST 12345678910111213141516171819axios.post('/user', {firstName: ' Nora',lastName: ' Simish'}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);});axios({method: 'post',url: '/user/12345',data: {firstName: ‘Nora',lastName: ‘Simish'}}); 执行多个并发请求 12345678910function getUserAccount() {return axios.get('/user/12345');}function getUserPermissions() {return axios.get('/user/12345/permissions');}axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) {// 两个请求现在都执行完成})) Nginx服务器 高性能web服务器：部署html/js/css/img/mp4…，web站点 反向代理：负载均衡 IMTP/POP3/SMTP代理服务器 安装 安装文件：1.16.1 centOS8安装依赖包 yum 安装yum install -y nginx Nginx配置相关文件 Nginx配置/etc/nginx/nginx.conf 1234567891011121314151617181920server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { }} 部署目录位置/usr/share/nginx/html 查看nginx服务是否启动 1234# 查看端口netstat -anp | grep 80# 查看进程ps -el | grep nginx 启动nginx服务 1nginx 发送请求访问（index），http://192.168.0.102 上传pie.html(/usr/share/nginx/html). http://192.168.0.102/pie.html 启动接口服务器 1nohup java -jar xxx.jar &amp; kill服务 123netstat -anp | grep 8081kill -9 9785","link":"/posts/2037924510/"},{"title":"2022年记——活着","text":"2022，对大多数人来说，都是不寻常的一年。是疫情，是封控，是放开，是离别，这一年发生了太多颠覆我认知的事，以至于分不清是我太天真，还是这个世界太魔幻。 若要用一个字总结这一年，便是“噩梦”的“噩”，上下左右均可翻转，就如这一年经历了这么多“反转”后，依旧逃不出“噩”字本身。 谨以此文，记录下亲身经历的2022… 2022年3月28日，是上海按下停止键的时刻，而这一刻，我还完全没意识到问题的严重性…… 侥幸逃脱的毒圈2022年1月6日，早已“零新增”多日的深圳又出现了病例，传闻离深需要48小时核酸阴性证明，本想离职后再逛逛这个城市的我，只能打消计划，立刻购买了返乡的机票。来深圳半年从未做过核酸的我，四处打听何处能做核酸。最后，终于在一个社区医院，排队一小时，花费了32.5元，做了人生的第一次核酸。排队时，不断有人在问“什么时候能出结果？”“今天的飞机赶得上吗？”，我暗自庆幸我的机票是第二天，同时也不禁感慨，原来深圳有这么多赶着回家的打工人啊。 8日晚，手持绿码，顺利登机的我终于松了一口气，看着舷窗外逐渐暗淡的灯光，告别了这个生活半年的城市。2小时后，随着轰鸣声停息，我打开手机，看着弹出的同事群99+条未读消息，有种不详的预感。“深圳带星了。”我立刻打开行程码确认，果然，“您14天内到访过：深圳市*”，没想到最终还是慢了一步。 万幸的是，我所在的那个区，还没有病例，因此，只是简单的做了个核酸就放我通关了。当然，还是免不了社区报备，喜提了14天居家健康检测和4次核酸。由于不能坐公共交通工具，每次都只能骑行半个小时去城郊的核酸点。 这次“跑毒”经历可以说是非常幸运了，回家后没多久，深圳就迎来了为期两周的“封城”。当时正庆幸跑毒成果的我，怎会想到更大的劫难正在前方等着我… “爱丁堡”的救赎过完年，2月底，我便如期奔赴上海，开展毕设。老师为我们订了酒店，虽然地处较偏，好在地铁通勤还算便利。每天通勤的路上我还在感慨，不愧是“精准防疫”的上海，路上大多数人已不戴口罩，冬日的暖阳照耀出一丝生机。 然而，意外总是来的很突然。本与在上海读书的旧友约定周末一聚，可尚未等到周末，却得知他们学校出现病例，已经封校。看着“深圳解封的新闻”，我还安慰他道“没事，最多两周肯定会好。”谁知这一封，便没有尽头… 3月14日 因为零星的新增病例，我已经开始了居家办公。一开始，我还喜于每天不用早起通勤，一个人在酒店呆着也没什么不好。一日三餐，生活照旧，外卖吃腻了，就去楼下转转吃碗面或馄饨。除了路上的人都带上了口罩，似乎没什么变化。 3月27日傍晚 我像往常一样，漫步在夕阳余晖下的街头，不知是因为疫情，还是生意不好，这几天开着的店越来越少了，逛了老半天，终于找到一家还在营业的面馆，点了一碗烩面。由于刚到饭点，店里人不多，老板娘时不时跟几位熟客攀谈几句。“也就你们几个天天来了“”最近的生意真不好做“不知道我们店还能开多久”。确实，因为周围小区零星出现的病例，店铺关了不少，我也只是在房间里呆久了，出来透透气。看着新闻中播着的“上海绝不封城”，我低头吸了口面，心想：最坏的情况也不过现在这样吧，很快就会好起来了。。。吧？ 晚上9点，酒店同住的同学突然跑来敲门，说上海明天要封城了，楼下小吃店老板娘接到通知明天不能营业了！听完，我是错愕的，“什么？封城？不是说不会封吗？”将信将疑下，赶紧询问酒店老板，证实了一小时前发新闻说明起要封4天。 毫无屯粮的我们一行5人便匆忙赶赴最近的超市。到了超市，这里早已是人山人海，蔬菜区挤满了人，但对于我们住酒店的来说，能用来饱腹的也只有泡面和自热米饭。但因为此前我也没有囤积食物的习惯，对于4天需要储备食物的数量没有明确的概念，并且既然官方通告上写了“保障外卖供应”，那我也没必要屯很多吧。因此最后我也只不过买了勉强够吃4天的泡面和自热饭，外加一打鸡蛋。 3月30日 封控头两天过的还算顺利，吃着泡面刷着新闻笑侃浦西人民的抢菜行为。但到了第三天，随着囤粮减低，看到外卖平台依旧空空如也，仅剩几家药店和花店还在营业。顿时心中就慌了，这也是我平生第一次因温饱而焦虑，难以相信这个国际化大都市竟无法满足人最原始的生存需求，这给我一种时空错乱，仿佛回到了长辈口中的“三年自然灾害时期”。2022年，在上海，你甚至能体会到花钱买不到食物，有钱无处可花的感觉！ 4月1日 原定的解封日已到，却丝毫未有解封迹象。此时，上海官方却回应说浦东地铁交通已经恢复，物资供应充足，居民“安全感满满”！刚想开骂，却被下面的新闻堵住了嘴： 哦，原来我不是“洋人”，怎配享受居民的待遇呢？封控前给我2小时采购物资，已经得给老爷们感恩戴德了。 封控前2小时采购的物资到今天为止已经见底，而外卖继续暂停，快递依旧停滞。看了看仅剩的一碗泡面，喝了一大口水，思考着中午吃面，晚上喝汤，能活下去吗？ 当真正面临饥饿的恐惧时，我也早已无心学习了，一边刷着几个外卖平台，一边看着微博上各种“黑色幽默”，这一天，是那么的孤独无助。万幸的是，偶然间终于刷到有一家超市营业了，立刻点进去划到食品一栏，在一连串的“售空”中终于找到了一包速冻汤圆，也管不了怎么吃了，只要是食物，就立刻下单。吃到了这几天来最饱的一餐。 4月2日 今天，浦西如期封了，但浦东却依旧封锁着。食物准备的再充足，到今天也都该见底了。酒店终于答应尽量帮我们解决吃饭的问题，但食材数量有限，只够每天提供一顿，这也成了此后1个多月时间，我每天唯一能吃到的一顿正经饭！ 30元的饭，一荤一素，放平时怎么看都是抢钱，但放现在，与外卖平台上为数不多几家动辄几百元起送，数十元配送费的外卖来说，这已经是最“经济实惠”的选择。 最初几天，早上还有包子提供，勉强可以保证一天2顿有的吃，但慢慢的，早餐的供应量在减少，到最后，对于两百来人居住的酒店，一天仅提供二三十份早餐，可想而知，多数时间仍只能与泡面相伴。 4月10日 封控开始整整14天后，政府终于想起了我们这群居无定所的可怜人，发放了一箱泡面。此后，差不多每周发放一次，直到我逃离上海，共受到了6次，基本以泡面火腿肠为主，但也不乏一些“特别款”，如神药“连花清瘟”以及不知配方的“中药汤剂”。当然最无语的还是给我们这些居住于酒店，无法动火的人发了一箱“油盐酱醋”。 4月18日 老师给我们送的救济物资终于到了，感谢老师把学校的配给物资省出来给我们。可惜这时政府还没发调料，身边也没有用于切割食材的工具，于是，就诞生了银行卡切土豆，方便面调料烧排骨这道黑暗料理。 4月21日 听到可以出门下楼的通知，下楼却发现仍然置身于围墙当中。本以为迎来的是解封，没想到是更严格的封控。集装箱堵路，铁丝网封道，路边的落叶已积成堆，此情此景，若不是今天阳光明媚，真以为来到了末世。 “明天会更好吗？” “等通知！” 5月14日 转眼，日子来到了5月，临近毕业，我还有一大堆事情等着回校解决。而解封的日子似乎还是遥遥无期。“下周会解封吗？”是群里问的最多的问题，在这”中国式辟谣”满天飞，“辟谣者”堂而皇之散布谣言的时期，没人知道该相信谁，也没人敢去相信谁。当看到外地的亲朋好友问起“看新闻说你们那儿都好了吧”时，我感觉自己像是被社会抛弃的人，生活在一个虚假的世界，一个外人无法理解的世界。看着楼下日渐加厚的铁皮围墙，仿佛要把我困在这里一辈子。难不成还等着有人来拯救吗？ “是时候该逃跑了！” 逃亡之路800元车票，300km离浦，14天隔离 To be continued. 2022.12.31 今天是2022年最后一天，本该一个人在宿舍平平静静送走这魔幻的一年，没想到在这一年还剩不到6小时的时候，命运却给了我最沉重的一击——外公去世了。 “外公不行了”当看到我爸的这条消息时，我是错愕的。为什么？外公不是已经康复了？不只是“轻症”吗？不是没有后遗症吗？为什么，就毫无征兆的倒下了？是肺炎？是心脏病？从未经历亲人离世的我甚至还没感受到悲伤。 “现代医学这么发达，应该会没事的吧？”此时的我还能平静地拨通我爸的电话，直到电话那头传来，“心脏已经停了。医生说就不回来了。” 我愣住了，不知道该说什么，心中还是充满了怀疑和侥幸，“心肺复苏已经做了，也没用。”，“120根本叫不到，我跟你舅自己抬去医院的，但还是太晚了。”一连串的真相让我不得不接受这个事实，也让我切身感受到奥密克戎的可怕，也让我终于明白了为什么那么多能享受到完备医疗资源的老院士们都没能挺过。网上流传的哪些“火葬场的烟火气”，“医院的报复性消费”也不是空穴来风。戏谑的背后是惨痛的真相。 “悲剧就是把美好的事物撕碎给人看。”如果没发生意外，明天就是外公九十大寿的日子；如果没有“一刀切”放开，外公也不会得病；如果医疗资源没有受到挤兑，外公或许还救得回来……本应是个大喜的日子却成为了没能逃过的一劫。人已驾鹤，而墙角的寿礼糕点还未全散去。 人生没有如果，过去没有重来。逝者已逝，只愿外公走的安详。R.I.P 谢谢你，2022，教给我这么沉痛的一堂人生大课！ 明天会更好 吗？","link":"/posts/3955856662/"},{"title":"Flume安装与应用","text":"Flume概述 日志采集和汇总工具 收集到的日志数据汇总到HDFS存储 flume: 1.9.0 Flume组件 source：数据源（需要采集的数据） channel：临时存储的数据位置，通常存储在内存 sink：数据目标存储，hdfs 安装 上传安装文件 解压 12tar zxvf apache-flume-1.9.0-bin.tar.gzsudo mv apache-flume-1.9.0-bin /usr/ 配置环境变量，~/.bash_profile 123456789JAVA_HOME=/usr/jdk1.8.0_231HADOOP_HOME=/usr/hadoop-3.2.1FLUME_HOME=/usr/apache-flume-1.9.0-binPATH=$FLUME_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$JAVA_HOME/bin:$PATHexport JAVA_HOMEexport HADOOP_HOMEexport FLUME_HOMEexport PATH 注意：source ~/.bash_profile Flume基本配置，$FLUME_HOME/conf/flume-env.sh 1234$ cp flume-env.sh.template flume-env.sh$ vi flume-env.sh 22 export JAVA_HOME=/usr/jdk1.8.0_231 解决jar包冲突 12345678910cd /usr/apache-flume-1.9.0-bin/lib/ll guava-11.0.2.jar-rw-rw-r-- 1 hadoop hadoop 1648200 9月 13 2018 guava-11.0.2.jarcd /usr/hadoop-3.2.1/share/hadoop/common/lib/ll guava-27.0-jre.jar-rw-r--r-- 1 hadoop hadoop 2747878 9月 10 2019 guava-27.0-jre.jarrm -rf /usr/apache-flume-1.9.0-bin/lib/guava-11.0.2.jarcp /usr/hadoop-3.2.1/share/hadoop/common/lib/guava-27.0-jre.jar /usr/apache-flume-1.9.0-bin/lib/ 实现数据同步 功能需求 采集爬虫服务器数据 实现步骤 启动数据采集服务 启动hdfs服务，保证hdfs可读写 配置Agent（source、channel、sink） 使用flume1.7+版本新特性，source组件提供了高可靠的同步模式（TAILDIR），保证数据不丢失 编写运行脚本（shell）并执行 配置文件 1234cd /usr/apache-flume-1.9.0-bin/mkdir myconfcd myconf/ vi flume-taildir-memory-hdfs.properties 1234567891011121314151617181920212223242526272829303132333435创建agent配置文件`flume-taildir-memory-hdfs.properties`，内容如下：```sh# Name the components on this agenthdfs_agent.sources = r1hdfs_agent.sinks = k1hdfs_agent.channels = c1# Describe/configure the sourcehdfs_agent.sources.r1.type = TAILDIRhdfs_agent.sources.r1.filegroups = f1hdfs_agent.sources.r1.filegroups.f1 = /home/hadoop/spider/data/collect/.*\\.loghdfs_agent.sources.r1.positionFile = /home/hadoop/spider/data/.flume/taildir_position.json# Describe the sinkhdfs_agent.sinks.k1.type = hdfshdfs_agent.sinks.k1.hdfs.path = hdfs://hadoop:9000/flume/hdfs_filegroups_source/%Y-%m-%d/hdfs_agent.sinks.k1.hdfs.rollInterval = 3600hdfs_agent.sinks.k1.hdfs.rollSize = 1048576hdfs_agent.sinks.k1.hdfs.rollCount = 0hdfs_agent.sinks.k1.hdfs.filePrefix = log_file_%Hhdfs_agent.sinks.k1.hdfs.fileSuffix = .loghdfs_agent.sinks.k1.hdfs.fileType = DataStreamhdfs_agent.sinks.k1.hdfs.useLocalTimeStamp = true# Use a channel which buffers events in memoryhdfs_agent.channels.c1.type = memoryhdfs_agent.channels.c1.capacity = 1000hdfs_agent.channels.c1.transactionCapacity = 100# Bind the source and sink to the channelhdfs_agent.sources.r1.channels = c1hdfs_agent.sinks.k1.channel = c1 创建hdfs目录 1hdfs dfs -mkdir -p /flume/hdfs_filegroups_source/ 编写shell脚本，安装目录下创建mysbin目录，start_taildir_memory_hdfs.sh，内容如下： 123456789101112$ cd /usr/apache-flume-1.9.0-bin/$ mkdir mysbin$ cd mysbin$ vi start_taildir_memory_hdfs.sh#!/bin/bashROOT_PATH=$(dirname $(dirname $(readlink -f $0)))cd $ROOT_PATHbin/flume-ng agent --conf ./conf/ -f myconf/flume-taildir-memory-hdfs.properties -Dflume.root.logger=INFO,console -n hdfs_agent 更改脚本的执行权限 1chmod 755 start_taildir_memory_hdfs.sh 执行start_taildir_memory_hdfs.sh脚本文件，命令如下： 1nohup ./start_taildir_memory_hdfs.sh &amp;","link":"/posts/1951150711/"},{"title":"Caddy配置指南","text":"下载安装从Github的release页下载相应操作系统的最新版本，使用dpkg安装 12wget https://github.com/caddyserver/caddy/releases/download/v2.7.6/caddy_2.7.6_linux_amd64.debsudo dpkg -i caddy_2.7.6_linux_amd64.deb 验证是否正确安装 二进制文件位置 12which caddy# /usr/bin/caddy caddy用户 （若未建立请手动添加👉添加用户） 12id caddy# uid=998(caddy) gid=998(caddy) groups=998(caddy),33(www-data) systemd配置文件 安装完成后会自动生成systemd配置文件，位于/lib/systemd/system/caddy.service，内容如下： 123456789101112131415161718192021[Unit]Description=CaddyDocumentation=https://caddyserver.com/docs/After=network.target network-online.targetRequires=network-online.target[Service]Type=notifyUser=caddyGroup=caddyExecStart=/usr/bin/caddy run --environ --config /etc/caddy/CaddyfileExecReload=/usr/bin/caddy reload --config /etc/caddy/Caddyfile --forceTimeoutStopSec=5sLimitNOFILE=1048576LimitNPROC=512PrivateTmp=trueProtectSystem=fullAmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE[Install]WantedBy=multi-user.target 可见caddy默认加载的Caddyfile配置文件位于/etc/caddy/Caddyfile，在后续配置站点的过程中，也只需要编辑该文件即可。 添加用户（可选）添加一个名为caddy的用户用于运行Caddy程序。 12345678sudo groupadd --system caddysudo useradd --system \\ --gid caddy \\ --create-home \\ --home-dir /var/lib/caddy \\ --shell /usr/sbin/nologin \\ --comment &quot;Caddy web server&quot; \\ caddy 注意：caddy用户的home目录位于/var/lib/caddy，静态文件需要放在这个目录下才能访问。 配置文件1vim /etc/caddy/Caddyfile 12345678910111213141516171819202122# To use your own domain name (with automatic HTTPS), first make# sure your domain's A/AAAA DNS records are properly pointed to# this machine's public IP, then replace &quot;:80&quot; below with your# domain name.:80 { # Set this path to your site's directory. if your root path starts with /, you'll need to add a * matcher token to distinguish it from a path matcher. root * /usr/share/caddy # Enable the static file server. file_server # Another common task is to set up a reverse proxy: # reverse_proxy localhost:8080 # Or serve a PHP site through php-fpm: # php_fastcgi localhost:9000}# Refer to the Caddy docs for more information:# https://caddyserver.com/docs/caddyfile 常用配置官方文档：https://caddyserver.com/docs/caddyfile 静态文件加上brower可以显示文件列表，否则智能访问指定路径的文件。 12345:8005 { root * /var/lib/caddy file_server brower} 反向代理123456789:8005 { reverse_proxy /v1/* localhost:9000 reverse_proxy /v2/* localhost:9001 @websockets { # 通过header中的字段匹配websocket请求 header Connection *Upgrade* header Upgrade websocket } reverse_proxy @websockets localhost:6001} 路径匹配有时候会需要根据路径把请求转发给不同的服务器，比如将/v1/开头的转发给openai，把/v2/开头的转发给closeai，但转发给closeai接收的路径也需要是/v1/，这就需要先匹配/v2/再替换成/v1/再转发给closeai服务器。 123456789101112131415:8080 { import log_file openai reverse_proxy /v1/* { to https://api.openai.com header_up Host api.openai.com } handle_path /v2/* { # 注意：该操作会自动移除匹配到的前缀 rewrite * /v1{uri} reverse_proxy { to https://api.closeai.com header_up Host api.closeai.com } }} 错误码处理12345678910111213:8080 { ... handle_errors { @5xx `{err.status_code} &gt;= 500 &amp;&amp; {err.status_code} &lt; 600` handle @5xx { respond &quot;503 \\{\\&quot;msg\\&quot;: \\&quot;Proxy Server Error\\&quot;\\}&quot; } handle { respond &quot;{err.status_code} {err.status_text}&quot; } }} 日志文件为方便多站点复用配置，可以新建一个snippet： 123456789101112131415(log_file) { log { format filter { wrap console fields { request&gt;headers&gt;User-Agent delete } } output file /var/log/caddy/{args[0]}.access.log { roll_size 10mb roll_keep 3 roll_keep_for 7d } }} 在站点配置中引用log_file即可，后面加上一个参数，表示自定义的文件名，如： 1234gh.luzy.top { import log_file gh reverse_proxy * localhost:7703} 其他使用ufw管理防火墙 设置默认关闭所有端口 123sudo apt-get install ufwsudo ufw enablesudo ufw default deny 设置启用端口（可用服务名或端口号） 123sudo ufw allow 22/tcpsudo ufw allow httpsudo ufw allow https 删除规则 1sudo ufw delete allow https 查询状态 1ufw status 重载firewall 1ufw reload","link":"/posts/2145646931/"},{"title":"GitHub学生包 | 免费领取$50 DigitalOcean优惠福利","text":"这次来谈一谈我这台服务器的申请流程，虽然遇到了一些坑，但最后还是成功只花5美元可以使用一年。 学生认证申请流程1. 注册一个全球最大同性交友平台Github账号最好用你学校的邮箱注册（就是有.edu的那个，应该每个大学都有吧，如果不知道请自行咨询学校网络中心），这样会方便很多。已经用别的邮箱注册了Github也不要紧，在后面的流程里添加一下就行。 2. 申请学生认证申请戳 这里点击Get Your Pack进入学生优惠，登录你的GitHub账号。点击Yes, I'm a student填入一些必要的信息。没有用edu邮箱注册的，添加你的edu邮箱进行验证即可，如果没有edu邮箱的话，貌似也可以直接使用学生证来进行验证，等待几个工作日，去邮箱查看申请是否成功。邮箱中受到如上信息就是注册成功了。然后你就可以打开链接领取你的学生福利了。重点看这里，用你的code就能换50刀了。 DigitalOcean注册流程•先注册Paypal由于Digital Ocean只支持信用卡和Paypal，所以我们中国用户基本上只能用Paypal支付了。由于Paypal注册现在好像也要实名上传证件什么的，审核过程比较慢，强烈建议各位提前注册好PayPal账号！（泪具体注册流程就不细说了，各位自己去PayPal官网注册吧 •DigitalOcean注册回归正题点击这里我的邀请码即可注册。注册即可获得$50的credit（一个月就会过期哦）我们要领的Github优惠是12个月的 ps.最近貌似DO网站不太稳，可能需要梯子才能上去，或者用Chrome的谷歌上网助手插件也行（好像是因为网站上用了一些404的插件。。。） ::warning:这里有个大坑！！！注册完后你根本找不到输code的地方！！！我当初没注意到这个问题以为看到$50到账就好了，结果一个月后50美金突然蒸发，我才注意到账单中写着30 day expiration 这就代表有效期只有一个月！！！ 不过碰到了上述情况也别担心，给客服发ticket让他们帮忙手动添加就行。点击右上角的support，就是那个救生圈一样的图标再拉到最下面，点这个像这样填好工单，把你的code发过去，等候客服回复。提醒一下，最好在工作日发，我第一次是在周日发的，结果到周二都没回复，等不及了就又发了一封，结果5分钟就回复了！w(ﾟДﾟ)w50刀记得在12个月内用完！? 欸，等等，虽然我已经用了一个月了，但他时间是给我从现在算的，那我岂不是白嫖了上个月的5美金？?早知道上个月就该把$50全用掉的 至此，你真的可以5美元白嫖（并不是）一年服务器了！Yeah~~","link":"/posts/4046649017/"},{"title":"Github+jsDelivr+Coding 免费高速稳定图床get!","text":"图床一直是影响博客撰写体验的重要工具，之前我一直用的是sm.ms图床，配合Typora的图片上传功能，可谓写作体验极佳。sm.ms图床虽然才成立没几年，但作为免费图床，自带https，免账号上传，注册就有有后台管理，就已经吊打不少家了。总体而言，他的速度还算不错，但免不了有时候抽风，而且毕竟一小厂，现在又近乎用爱发电，万一哪天跑路了，博客里挂着的那些图岂不全没了。所以既想有稳定的体验，又想免费白嫖，可谓鱼和熊掌不可兼得啊。 不过最近我还真就发现了这近乎完美的解决方案。用GitHub作为存储，jsDelivr作为CDN加速，如有必要，还可加上国内的Coding作为跳板，提升稳定性。 首先这几个都是大厂完全不必担心跑路。GitHub就不必说了，jsDelivr由ProspectOne维护的公共库，免费提供了npm和GitHub仓库的静态文件加速服务，可以说非常的良心，而且它在中国大陆也有数百个节点，可以说访问速度极佳，一张3mb的图片加载速度不到1秒钟！ 之所以我还多用了个腾讯的Coding，是因为国内的GitHub访问真的太不稳定了，上传失败的概率非常高。虽然Coding有放外链机制，速度也不是很快，但不妨让他做个跳板，帮我们自动把图片同步到GitHub仓库。 下面正式开始教程： Github仓库配置新建GitHub仓库这一步就不必多说了，直接登录账号点击New新建一个仓库即可。可以选择放个readme作为初始化。注意一定要选择Public公开仓库，不然jsDelivr就无法访问你的仓库数据了。 生成Token点击右上角头像选择setting 然后选择Developer settings 选择Personal access tokens，点击Generate new token 输入名称，勾选第一个repo权限，点击下方Generate token按钮 之后会显示出生成的token，⚠注意不要立刻关闭这个页面！注意不要立刻关闭这个页面！注意不要立刻关闭这个页面！这个token只显示一次！ 不过就算忘记保存了也没事，再点击那条记录，点Regenerate即可。 PicGo配置安装点击前往下载，根据readme里的安装教程即可。 配置GitHub图床填写如下配置： 设定仓库名：按照用户名/图床仓库名的格式填写 设定分支名：master 设定Token：粘贴之前生成的Token 指定存储路径：填写想要储存的路径，如img\\，这样就会在仓库下创建一个名为img的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的的作用是，在图片上传后，PicGo会按照【自定义域名+上传的图片名】的方式生成访问链接，放到剪贴板上，因为我们要使用jsDelivr加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名 关于jsDelivr引用资源的链接格式 访问仓库文件：https://cdn.jsdelivr.net/gh/user/repo/file 访问最新文件：https://cdn.jsdelivr.net/gh/user/repo@latest/file 按版本号访问：https://cdn.jsdelivr.net/gh/user/repo@1.2/file 需要在GitHub上发布release，作为图床不适用 注：jsDelivr缓存机制未知，格式2大部分时候是实时更新的，有时可能需要等待一段时间 到此为止，GitHub+jsDelivr图床已配置完毕，可以使用PicGo一键上传图片了~再设置好Typora自动上传图片，写作效率++！ 注意事项 GitHub图床不支持同名文件上传，可以在设置里调整为以时间戳命名。 GitHub国内访问较不稳定，上传失败可能性较大，解决方案可参考下文配置Coding图床+GitHub自动同步 配置Coding图床+GitHub自动同步Coding是基于腾讯云的一个在线项目管理平台，相比Gitee功能更丰富，以及拥有类似GItHub Action的功能，可以配置自动工作流。同时因其支持Pages服务，我将它作为了博客的国内的分流站点，提升国内访问速度。详情可参考我的另一篇文章：Hexo折腾系列（一）博客访问速度优化 这里我将把它作为一个中间跳板，解决GitHub图床上传不稳定的问题。 创建Coding仓库如果你已经有腾讯云账号，从这个🔗链接 进入； 如果你没有腾讯云账号，可以直接从🔗Coding官网注册。 ⚠注意这两个账号不互通！ 切换到项目一栏，点击右上角创建项目，一定是新建一个项目，不是原有项目里的一个仓库！ 选择DevOps项目，注意要勾选开源仓库，不然外链无法访问！ 接下来申请token，步骤跟GitHub类似，同样这个token只显示一次，一定要记下来！！！ PicGo-Coding插件配置PicGo本体是不支持Coding的，但已经有大佬开发了插件，在插件中心搜索coding即可。🔗插件地址 安装完成后重启一下PicGo，在图床设置里就能找到Coding图床了。 团队名称: coding.net团队名称 项目名称: 需要保存图片的库名 token: coding.net’s api token 分支: 需要存放图片的分支。默认master 存储文件夹: 需要存放照片的指定文件夹 按年月日存放: 图片自动按日期路径存放与库中，可以存储文件夹混合使用 以我的仓库为例： 团队名称为luzy999，项目名称为cdn，分支为master，指定的文件夹为img 到此为止Coding图床已经搭建完毕了，可以上传图片试试。 但这还不是我的最终目的，Coding的国内访问速度还算可以，但相比强大的jsDelivr，差距还算不小的，但jsDelivr只提供GitHub仓库的加速。那有没有办法让他也加速Coding呢？ 对此我想出了一个迂回方法，Coding不是有构建计划功能吗，那我每次提交图片到Coding，让他再自动同步到GitHub不就成了！ 配置Coding自动同步功能在持续集成菜单下有个构建计划功能，点击创建。 选择自定义构建过程 切换到文本编辑器： 输入以下代码： 1234567891011121314151617181920212223242526272829pipeline { agent any stages { stage('检出') { steps { checkout([ $class: 'GitSCM', branches: [[name: env.GIT_BUILD_REF]], userRemoteConfigs: [[url: env.GIT_REPO_URL, credentialsId: env.CREDENTIALS_ID]] ]) } } stage('拉取合并') { steps { sh '''url=&quot;https://${username}:${token}@github.com/${username}/${repo}.git&quot;git pull $url''' echo '合并成功！' } } stage('推送部署') { steps { echo '正在推送文件...' sh '''url=&quot;https://${username}:${token}@github.com/${username}/${repo}.git&quot;git push -f $url HEAD:master''' echo '已完成推送.' } } }} 添加环境变量 username为GitHub用户名 token为GitHub的token，注意是GitHub的，如果忘了，再去申请一个就行。👉回上面看看 repo为GitHub上的仓库名 点击触发规则，设置推送到master时自动触发： 可以点击立即构建测试一下是否成功。 看看效果： 同样一张3.1mb的图片，Coding加载花了1.3s，而jsDelivr只花了363ms！加速效果还是很明显的！ 最后再来提几点注意事项： Coding免费版每周可以免费构建200次，也就是说可以推送200张图片，也基本够用了。 由于picgo-coding插件暂时不支持自定义域名，所以返回的图片url还是Coding仓库的地址，如果要替换成jsDelivr的地址，只能写完后再全局搜索替换一下了，也不是很麻烦。 【更新】作者非常给力，提交了issue，立刻就上线了自定义域名这个功能，不过由于同步需要时间，就不能实时显示图片了，可以说有利有弊吧。 配置Github Action自动压缩图片✨这几天碰巧看到一篇文章，我的 gitee 图床，自动上传、压缩、获取图片 url，可以利用GitHub Action实现自动压缩图片。 安装ImgBot为 github 仓库安装 ImgBot 机器人。 打开 ImgBot 网站，点击 【try for free】， ImgBot 声称开源项目能够一直免费使用其服务。 从 ImgBot 网站跳转到 github 网站后，点击 【Set up a plan】 按钮，在下一步中选择 【Open Source】 这一个免费计划。下一步是【Install it for free】。 最后到这下图这个步骤，选择为刚刚创建的图床仓库打开 ImgBot。 这个Bot会自动检索仓库中的图片文件，进行压缩后提交Pull Request，但需要手动点击合并，就很麻烦。但别担心，强大的GitHub Action同样可以自动化处理合并请求。 配置自动合并Workflow点击GitHub仓库中的【Actions】，选择【New Workflow】，输入如下代码： 123456789101112131415161718192021222324252627name: Merge Imgboton: pull_request: types: - opened - ready_for_review pull_request_review: types: - submitted status: {}jobs: automerge: runs-on: ubuntu-latest steps: - name: automerge uses: &quot;pascalgn/automerge-action@v0.9.0&quot; env: GITHUB_TOKEN: &quot;${{ secrets.GIT_TOKEN }}&quot; MERGE_LABELS: &quot;&quot; MERGE_METHOD: &quot;squash&quot; MERGE_COMMIT_MESSAGE: &quot;pull-request-description&quot; MERGE_FORKS: &quot;false&quot; MERGE_RETRIES: &quot;2&quot; MERGE_RETRY_SLEEP: &quot;10000&quot; UPDATE_METHOD: &quot;rebase&quot; 这其实是使用了一个auto-merge插件，详细配置见官方文档。一般也不用修改。 最后别忘了在仓库的setting中加入GitHub Token 看看压缩效果：","link":"/posts/214001566/"},{"title":"Git学习笔记","text":"提交代码 本地初始化环境 git init 创建服务关联到仓库 git remote add duckfarm http://username:password@xxxx.git 拉取服务器仓库的环境 git pull --rebase duckfarm master 创建分支 git branch localbranch 在分支中工作 git checkout localbranch 提交分支的文件到本地仓库 暂存 git add . 提交 git commit -a -m &quot;Day 0 Note&quot; 同步本地代码到服务器仓库 git push --set-upstream duckfarm localbranch 合并 克隆仓库 git clone http://xxx.git 本地创建成员分支 git checkout -b localbranch origin/localbranch 切换到主分支 git checkout master 进行分支合并 git merge localbranch 本地提交 git commit -a -m &quot;v1.1&quot; 同步到服务器 git push --set-upstream origin master","link":"/posts/2837359218/"},{"title":"Go语言学习笔记","text":"Hello world123456package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;hello&quot;)} package main表示一个可独立执行的程序，main函数必须写在main包里，每个 Go 应用程序都包含一个名为 main 的包 {不能换行 输入go run hello.go运行，go build hello.go编译 基础语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 当前程序的包名package main// 导入其他包import &quot;fmt&quot;import . &quot;fmt&quot; // 类似于python的import * from// 同时导入多个import ( &quot;fmt&quot; &quot;math&quot;)// 常量定义const PI = 3.14// 可以用作枚举类型const ( Unknown = 0 Female = 1 Male = 2)const ( a = iota // 0 b = iota // 1 c = iota // 2)// 全局变量的声明和赋值var name = &quot;go&quot;var flag bool // 声明var flag = false // 声明+初始化flag := false // （等价于↑）简短声明// 一般类型声明type newType int// 结构的声明type user struct{}// 接口的声明type golang interface{}// 函数名首字母小写即为 private；大写表示public，可以被外部包调用func getId() int {}func Printf() {}//可以返回多个值func numbers()(int,int,string){ a , b , c := 1 , 2 , &quot;str&quot; return a,b,c}// for 循环 (没有while关键字)for i := 0; i &lt; 100; i++ {}for true {}// 数组var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}balance :=[...]float32{1.0,2.0,3.0} // ... 可省略len(balance) // 长度numbers := make([]int,0,5) // (类型,len,cap)// 追加元素balance = append(balance, 5, 6, 6, 7)// 切片，容量不会改变s := []int{2, 3, 5, 7, 11, 13} // len=6 cap=6 [2 3 5 7 11 13]s = s[:0] // len=0 cap=6 []s = s[:2] // len=2 cap=6 [2 3]// range 遍历for i, num := range nums { if num == 3 { fmt.Println(&quot;index:&quot;, i) }}// map/* 声明变量，默认 map 是 nil，若不初始化，不能插入 */var map_variable map[key_data_type]value_data_type/* 或 使用 make 函数 */map_variable := make(map[key_data_type]value_data_type) OOP类Go没用类，但可以给struct定义方法 1234567891011121314151617181920212223type Student struct { id int name string grade1 float32 grade2 float32}// 接收者↓func (s Student) getAvg() float32 { return (s.grade1 + s.grade2) / 2.0}// 指针接收者↓（可以修改成员变量的值）func (s *Student) setName(name string){ s.name=name}func structTest() { s1 := Student{id: 10, grade1: 85} s1.grade2 = 90 s1.setName(&quot;AA&quot;) fmt.Println(s1) fmt.Println(&quot;avg&quot;, s1.getAvg())} 接口1234567891011121314151617181920212223242526272829303132333435363738// interfacetype People interface { GetName() string}type Student struct { name string age int}// 指针接收者func (s *Student) GetName() string { return s.name}type Teacher struct { name string age int}// 值接收者func (t Teacher) GetName() string { return t.name}func interfaceTest() { var p1 People t := Teacher{name: &quot;t1&quot;} s := Student{name: &quot;s1&quot;} p1 = t // Teacher 实现了 GetName() p1.GetName() p1 = &amp;t // *Teacher 的实体实现了GetName() p1.GetName() // 实际(*p1).GetName() //p1 = s // 错误：Student 没有实现GetName()方法 p1 = &amp;s // *Student 实现了GetName()方法 p1.GetName()} 总结：实现了值接收者的方法，相当于自动实现了指针接收者的方法；而实现了指针接收者的方法，不会自动生成对应值接收者的方法。 类型断言12345678910111213141516var i interface{} = &quot;hello&quot;// t := i.(T) // 访问接口i底层的具体值，只有接口能调用该方法s := i.(string)fmt.Println(s)// 可返回两个值，第二个值表示是否成功（不会报错）s, ok := i.(string)fmt.Println(s, ok)// hello truef, ok := i.(float64)fmt.Println(f, ok)// 0 falsef = i.(float64) // 报错 panic: interface conversion: interface {} is string, not float64fmt.Println(f) 类型选择可以用switch语句进行类型判断 12345678switch v := i.(type) {case T: // v 的类型为 Tcase S: // v 的类型为 Sdefault: // 没有匹配，v 与 i 的类型相同}","link":"/posts/3561709949/"},{"title":"Hexo折腾系列（一）博客访问速度优化","text":"这几天一直在折腾Hexo博客站，功能上已经整的差不多了，markdown写作非常舒适。但由于是部署在GitHub Pages 上，国内访问速度真的一言难尽。于是就在寻找国内有没有免费的静态网站托管平台。首先找到的就是Gitee，结果却发现免费版不支持自定义域名和ssl，那显然是用不了了。之后终于找到了腾讯云的Coding平台，支持免费静态网站部署，且支持自定义域名和ssl，基本符合我的要求了。 使用Coding平台部署网站注册账号首先当然是要注册，一开始不知道这平台是腾讯的，账号跟腾讯云互通，用了没绑定过腾讯云的微信注册了，绑定了不少个人信息，结果却发现不能跟我已有的腾讯云账号绑定！WTF，最要命的是竟然不支持注销账号！（不愧的tx的尿性）最后没办法，毕竟还是要用他的工具，只能放弃这个账号，从腾讯云控制台重新开通Coding。👉传送门 如果你已经有了腾讯云账号，一定要在这里点使用！不要直接百度进coding官网！（当然你想重新注册一个账号无所谓） 配置Git仓库说实话，Coding看着功能挺多的，界面看着眼花缭乱的。😵 创建仓库 切换到项目一栏，点击右上角创建项目 选择DevOps项目 设置部署公钥 在项目内设置公钥（只能作用于本项目），或者在个人设置里添加公钥（全局）均可。 测试一下公钥： 1ssh -T git@git.coding.net 部署项目获取项目仓库的ssh访问地址，复制其内容： 修改博客根目录下的_config.yml文件，修改deploy部分： 123456deploy: type: git repo: github: git@github.com:username/username.github.io.git coding: git@e.coding.net:username/name/name.git # 新增地址 branch: master 重新执行hexo d部署命令，代码即可同时部署到Github和Coding上。 开启Pages服务在左边菜单中找到持续部署 里面有静态网站和静态网站V2，这两个我都试用过，静态网站基本类似Github Page 用这个基本够了。V2是部署到腾讯云的COS对象存储服务，功能更强大，可自定义构建流程，配置腾讯云CDN，但你需要有备案的域名，才能使用国内cdn，否则无法自定义域名。如果你选用境外cdn的话，速度反而更慢了，这显然违背了我的初衷。 因此，权衡之后，我还是使用了静态网站功能，虽然不能修改cdn，但域名不需要备案，且经测试，域名解析到新加坡腾讯云服务器，国内访问速度还可以。 配置自定义域名创建好静态网站后，点击设置，可以配置自定义域名，而且最多可以绑定5个。 需要注意的是，他的ssl只支持自动签发，你点击绑定后后台就自动申请证书了。因此为了确保成功，一定要先在你的DNS服务商处配好CNAME解析，等十分钟后再点击绑定。 证书状态显示正常后就能通过你的域名访问了。 分线路解析至此，部署工作基本完成了。为了使国内外用户都能拥有较好的访问速度，我们可以设置分线路解析。境内流量解析到Coding，境外流量解析到GitHub，这样一来能使访问速度最优化，二来能解决百度对github网站的收录问题。（还需时间验证） 目前有很多平台支持分流解析，比如腾讯云的DNSPod，阿里的万网。我的域名是在DNSPod买的，就直接在平台上设置就行。如果你买域名的服务商不支持分流解析，那也可以通过设置NS，转接到DNSPod平台。 如上图，根据不同线路指定不同的CNAME即可，当然你也可以单独给百度设置一个，优化爬虫采集。 验证成果使用站长工具进行ping测试： 可以看到，国内外实现了分流解析，效果还是非常明显的，国内访问速度提升不少。 压缩静态资源虽然已经优化了网络链接问题，但在一些较大的css，js文件上加载速度还是不尽人意。通过网上查询，目前发现有3款工具可以进行静态文件的压缩，一款是hexo-neat，操作起来非常简单，另一款是更为专业的gulp，最后发现的一款是hexo-all-minifier，他像是hexo-neat的增强版，也是我现在正在使用的。 hexo-neat使用hexo-neat使用起来非常方便，只需在站点根目录安装： 1npm install hexo-neat --save 在站点配置文件_config.yml的末尾添加配置： 12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' hexo-neat将在hexo g时自动执行，显示每个文件的压缩率。 缺点 经过测试，该工具貌似是在hexo生成静态文件之前对source内的文件进行压缩，对于hexo generate之后生成的css文件没有压缩作用。 gulp工具使用这款工具是较为专业的静态文件压缩工具，配置起来较为麻烦，坑也比较多。 按网上教程配好了却一直报这个错，最后才发现是版本问题，gulp@3的代码格式和gulp@4不同。 安装步骤 亲测可用 先安装依赖包 12npm install -g gulpnpm install gulp gulp-htmlclean gulp-htmlmin gulp-clean-css gulp-uglify-es gulp-imagemin del gulp-minify-inline-json --save-dev 在站点根目录下新建一个 gulpfile.js 文件，写入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101var gulp = require('gulp');var minifycss = require('gulp-clean-css');var uglify = require('gulp-uglify-es').default;var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');var del = require('del');var Hexo = require('hexo');var minifyInlineJSON = require('gulp-minify-inline-json');gulp.task('clean', function () { return del(['public/**/*']);});var hexo = new Hexo(process.cwd(), {});gulp.task('generate', function (cb) { hexo.init().then(function () { return hexo.call('generate', { watch: false }); }).then(function () { return hexo.exit(); }).then(function () { return cb() }).catch(function (err) { console.log(err); hexo.exit(err); return cb(err); })});gulp.task('deploy', function () { return hexo.init().then(function () { return hexo.call('deploy', { watch: false }).then(function () { return hexo.exit(); }).catch(function (err) { return hexo.exit(err); }); });});gulp.task('minify-css', function () { return gulp.src('./public/**/*.css') .pipe(minifycss({ compatibility: 'ie8' })) .pipe(gulp.dest('./public'));});gulp.task('minify-html', function () { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public'))});gulp.task('minify-img', function () { return gulp.src('./public/img/**/*') .pipe(imagemin([ imagemin.gifsicle({ interlaced: true }), imagemin.jpegtran({ progressive: true }), imagemin.optipng({ optimizationLevel: 5 }), imagemin.svgo({ plugins: [{ removeViewBox: true }, { cleanupIDs: false }] }) ])) .pipe(gulp.dest('./public/img'))});gulp.task('minify-js', function () { return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));});gulp.task('minifyInlineJSON', function () { return gulp.src('./public/**/*.html') .pipe(minifyInlineJSON()) .pipe(gulp.dest('./public'));});gulp.task('compress', gulp.series('minify-html', 'minify-css', 'minify-img', 'minify-js', 'minifyInlineJSON'));gulp.task('default', gulp.series('clean', 'generate', 'compress', 'deploy')); 运行命令： 12gulp # 包含 hexo c &amp; hexo g &amp; hexo dgulp compress # 只进行压缩 hexo-all-minifier使用这款工具我最后才发现，它兼顾了hexo-neat的易用性，和gulp的功能。 安装1npm install hexo-all-minifier --save 如果安装失败试试用cnpm（我就是这么安装成功的） 1cnpm install hexo-all-minifier --save 配置在_config.yml里添加: 1all_minifier: true 详细设置：（详见 README） 123456789101112131415161718192021222324252627282930313233# html压缩html_minifier: enable: true ignore_error: false exclude:# css压缩css_minifier: enable: true exclude: - '*.min.css' # js压缩js_minifier: enable: true mangle: true compress: exclude: - '*.min.js'js_concator: enable: false bundle_path: '/js/bundle.js' front: false silent: false# 图片优化image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false 优化效果 除去首页那张图片整体加载只用了不到3秒，优化效果还是非常显著的。","link":"/posts/2009685483/"},{"title":"Hello World","text":"号外！号外！我的个人小站上线啦！欢迎各位光临敝站！ 一代目WordPress版（2019.07.28~2020.07.04）R.I.P 二代目Hexo版（2020.07.04~ ?）","link":"/posts/1243066710/"},{"title":"Hexo折腾系列（三）永久链接优化","text":"Hexo永久链接的默认格式是 :year/:month/:day/:title/，年、月、日、标题，嗯，这链接看起来很清晰看起来很清晰啊，但一复制链接，那就。。。https://blog.luzy.top/2020/08/20/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86额，这一长串编码实在太不友好了，无论是对人还是对搜索引擎。 而且如果你一改标题，url马上就变了，对搜索引擎收录更不利了。 其实解决方法也很简单，只需安装一个插件即可。 安装插件在hexo站点根目录执行： 1npm install hexo-abbrlink --save 修改_config.yml配置文件123456# permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 然后再重新生成下网页，你会发现每篇文章的头部信息里都新增了一条abbrlink: xxxxxxxx记录，这就是这篇文章的永久id了，只要他不变，你的文章链接就不会变了。 再看一眼url，你会发现都变成了https://域名/posts/xxxxxxxx/的形式，比之前那一长串简洁明了了许多。","link":"/posts/2424649425/"},{"title":"Hexo折腾系列（二）自定义404页面","text":"一个成熟的网站当然要有他独特的404页面，使用GitHub Pages 部署的博客虽然有GitHub的默认404页面，但显然不够美观，也与我们的网站整体风格不搭。 要实现自定义404其实很简单，只要在网站的根目录放一个404.html文件即可。而对于我们使用的Hexo，则有更合适的处理方法。 创建404页面进入hexo站点的根目录，打开终端，输入： 1hexo n page &quot;404&quot; 将会在source目录下生成一个404文件夹，其中有一个index.md文件，这个文件其实就相当于是404.html了。 打开index.md，修改头部信息： 1234layout: falsecomments: falsetitle: 404permalink: /404 注意不要忘了修改permalink，不然不会在根目录下生成404.html。 编写404页面内容由于markdown是支持插入html内容的，因此只需要在这个md文件里写入html代码即可。要注意的是html代码之间千万不能有空行，不然会标签识别错误！ 那么接下来的就是考验你前端编码的能力和审美了。可惜本人不才，让我凭空写一个美观的网页几乎不可能，那只能靠拿来了！ 这里推荐一个404模板网站，有非常多美观的404页面，总能找到属于你的菜。 找一个你喜欢的模板，点击下载源码，里面一般包含了html+js+css。html刚才说了直接贴markdown文档里即可，而js和css可以放到刚才生成的404目录下。 同时别忘了修改html中的css和js引用地址： 123456&lt;!-- 网站icon --&gt;&lt;link rel=&quot;icon&quot; href=&quot;/img/favicon.svg&quot;&gt;&lt;!-- css文件 --&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/404/404.css&quot;&gt;&lt;!-- js文件 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/404/404.js&quot;&gt;&lt;/script&gt; 这样就基本完成了，hexo s看看效果： 有兴趣的话可以再微调下页面内容。","link":"/posts/456645515/"},{"title":"Hexo折腾系列（六）数学公式渲染优化","text":"有时候我们需要在文章里插入公式，Typora编辑器提供了很好的公式渲染支持，但这只能在本地编辑器里看到效果，而Hexo默认是不支持公式渲染的，因此很多Hexo主题都自带了katex或者mathjax组件来处理渲染数学公式。以我使用的Icarus主题为例，它本身就自带了这两款公式渲染工具，但实际使用效果却不佳，有些公式会显示不正确。究其原因，公式中的_等符号会被错误的识别为markdown语法，导致公式解析错误。本文综合了网上几种方法，得出了一个最为完美的解决方案。 出错原因为了从根源解决问题，我们首先需要分析出错的原因。Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线_代表斜体，会被渲染引擎处理为&lt;em&gt;标签。因此轮到MathJax引擎渲染的时候，其实公式原文已发生了改变。例如，$x_i$在开始被渲染的时候，处理为x&lt;em&gt;i&lt;/em&gt;​，这样MathJax引擎就认为该公式有语法错误，所以不会渲染。 类似的语义冲突的符号还包括* { }等。 官方解决方案👉官方文档地址 官方提供了两种结局办法： 如果要输入这样一个公式 \\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)正常情况下只要输入：123$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$ 但因为含有_歧义字符，需要转义： 123$$\\hat{x}\\_{k}=\\hat{x}\\_{k}^{-}+K\\_{t}\\left(y\\_{k}\\right)$$ 或者将整个公式用一个额外的HTML标签对包裹起来： 12345&lt;div&gt;$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$&lt;/div&gt; 但这两种方法的缺点是：其一，需要额外修改$\\TeX$代码，增添了不必要的麻烦；其二，Typora的实时渲染功能没有了。 最佳解决方案更换Hexo的markdown渲染引擎，hexo-renderer-kramed引擎是在默认的渲染引擎hexo-renderer-marked的基础上修改了一些bug，两者比较接近，功能也是兼容的。 cd到hexo根目录，通过npm安装 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 更换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为hexo-renderer-kramed引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\\kramed\\lib\\rules\\inline.js，把第11行和第20行做如下修改： 123456# line 11- escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/,+ escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/# line 20- em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,+ em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/ 之后重启hexo，问题完美解决！要注意的是这样修改后貌似只支持MathJax渲染器，不支持katex了，注意把主题配置文件中plugins &gt; mathjax的值设置为true。 12plugins: mathjax: true 参考资料[1] Icarus官方文档 [2] 在Hexo中渲染MathJax数学公式","link":"/posts/2968289947/"},{"title":"Hexo折腾系列（五）不蒜子计数器初始化","text":"不蒜子是一款简单好用的网站访客数量统计插件。只需两行代码，就可搞定静态网站的计数难题。许多Hexo主题也都内置了这个功能。 不蒜子好虽好，但有一大问题就是如果你换了域名，那你的访客计数就归零了。而官网上写的注册后初始化的功能也是被作者一鸽再鸽。因此要初始化访客计数就只能另辟蹊径了。 总结了网上的方法无非就是在全局加上一段js，在不蒜子计数加载完成后在加上一个初始值。 对于我使用的 Icarus主题，有两种修改方法： 修改主题代码方法一我在main.js中加上了如下代码： 1234567891011121314var config = window.IcarusThemeSettings;if (typeof config !== 'undefined' &amp;&amp; typeof config.busuanzi_site_offset !== 'undefined' &amp;&amp; config.busuanzi == true) { $(document).ready(function () { var int = setInterval(fixCount, 100); var busuanziSiteOffset = parseInt(config.busuanzi_site_offset); function fixCount() { if ($(&quot;#busuanzi_container_site_uv&quot;).css(&quot;display&quot;) != &quot;none&quot; &amp;&amp; parseInt($(&quot;#busuanzi_value_site_uv&quot;).html()) &gt; 0) { clearInterval(int); $(&quot;#busuanzi_value_site_uv&quot;).html(parseInt($(&quot;#busuanzi_value_site_uv&quot;).html()) + busuanziSiteOffset); } } });} 同时修改script.jsx，在导出的配置中加上busuanzi的相关配置 1234567891011121314 const embeddedConfig = `var IcarusThemeSettings = { site: { url: '${config.url}', external_link: ${JSON.stringify(externalLink)} }, article: { highlight: { clipboard: ${clipboard}, fold: '${fold}' } },+ busuanzi: ${config.plugins.busuanzi},+ busuanzi_site_offset: ${config.busuanzi_site_offset}, };`; 方法二只修改script.jsx，通过dangerouslySetInnerHTML的方式加入script标签： 1234567891011121314151617181920212223242526 // 加上这个const busuanzi_init = `if (typeof ${config.busuanzi_site_offset} !== 'undefined' &amp;&amp; ${config.plugins.busuanzi} == true) { $(document).ready(function () { var int = setInterval(fixCount, 100); var busuanziSiteOffset = parseInt(${config.busuanzi_site_offset}); function fixCount() { if ($(&quot;#busuanzi_container_site_uv&quot;).css(&quot;display&quot;) != &quot;none&quot; &amp;&amp; parseInt($(&quot;#busuanzi_value_site_uv&quot;).html()) &gt; 0) { clearInterval(int); $(&quot;#busuanzi_value_site_uv&quot;).html(parseInt($(&quot;#busuanzi_value_site_uv&quot;).html()) + busuanziSiteOffset); } } }); }`; return &lt;Fragment&gt; &lt;script src={cdn('jquery', '3.3.1', 'dist/jquery.min.js')}&gt;&lt;/script&gt; &lt;script src={cdn('moment', '2.22.2', 'min/moment-with-locales.min.js')}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: `moment.locale(&quot;${language}&quot;);` }}&gt;&lt;/script&gt; &lt;script dangerouslySetInnerHTML={{ __html: embeddedConfig }}&gt;&lt;/script&gt; {/* 加上这句 */} &lt;script dangerouslySetInnerHTML={{ __html: busuanzi_init }}&gt;&lt;/script&gt; {clipboard ? &lt;script src={cdn('clipboard', '2.0.4', 'dist/clipboard.min.js')} defer={true}&gt;&lt;/script&gt; : null} &lt;Plugins site={site} config={config} page={page} helper={helper} head={false} /&gt; &lt;script src={url_for('/js/main.js')} defer={true}&gt;&lt;/script&gt; &lt;/Fragment&gt;; } 添加配置文件使用上述任一种方法修改后，只需要在主题的配置文件_config.yml中加上： 1busuanzi_site_offset: 100 初始值改多少就看你了😉","link":"/posts/3966480924/"},{"title":"LCP-424 替换后的最长重复字符","text":"题目回顾 题目详情 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意：字符串长度 和 k 不会超过 104。 示例 1： 123输入：s = &quot;ABAB&quot;, k = 2输出：4解释：用两个'A'替换为两个'B',反之亦然。 示例 2： 12345输入：s = &quot;AABABBA&quot;, k = 1输出：4解释：将中间的一个'A'替换为'B',字符串变为 &quot;AABBBBA&quot;。子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。 Discussion | Solution 解法思路本题采用滑动窗口和双指针的思路来进行解题。（太久没做题了，标准题解看来半天才看懂） 从题目的要求来分析其实很好理解。要求最长的子串，那么肯定这个串是连续的（废话），所以就很适合用滑动窗口的方法，一个窗口从左移到右，寻找出符合条件的最大窗口长度，即为题目所求。本题的关键就在于如何控制窗口左右边界的移动。 先来看看怎样的窗口子串是符合条件的：要找到尽可能长的重复串，毋庸置疑，肯定是找出现次数最多的字母，同时你还可以最多把k的其他字符也变成它。所以符合条件的子串一定满足： 1窗口长度 - 同一字母最大出现次数 &lt;= k 窗口移动的规则即为： 右指针++ 若区间内窗口长度 - 同一字母最大出现次数 &gt; k左指针++ 以上操作保证了窗口长度只增不减，这样最后的窗口长度就是结果 比如那s = &quot;AABABBA&quot;, k = 1的例子 初始时左右指针都指向0 ↓ AABABBA ↑ 窗口长度(1) - 1 &lt; 1，r++ ↓ AABABBA ↑ 窗口长度(2) - 2 &lt; 1，r++ ↓ AABABBA ​ ↑ 窗口长度(3) - 2 &lt;= 1，r++ ↓ AABABBA ​ ↑ 窗口长度(4) - 3 &lt;= 1，r++ ↓ AABABBA ​ ↑ 窗口长度(5) - 3 &gt; 1，r++, l++ ↓ AABABBA ​ ↑ 窗口长度(5) - 3 &gt; 1，r++, l++ ​ ↓ AABABBA ​ ↑ 最终结果为 $r-l = 4$ 代码实现12345678910111213141516171819202122232425/* * @lc app=leetcode.cn id=424 lang=java * * [424] 替换后的最长重复字符 */class Solution { public int characterReplacement(String s, int k) { int[] cnt = new int[26]; int l = 0; int r = 0; int maxn = 0; // 窗口内出现最多次的字母个数 for (; r &lt; s.length(); r++) { cnt[s.charAt(r)-'A']++; maxn = Math.max(maxn, cnt[s.charAt(r)-'A']); if(r-l+1-maxn&gt;k){ cnt[s.charAt(l)-'A']--; // 窗口最左边的字符出去了 l++; } } return r-l; }} 时间复杂度O(n)，空间复杂度O(|M|)","link":"/posts/1594990787/"},{"title":"Hexo折腾系列（四）鼠标指针美化","text":"又来整些花里胡哨的玩意儿（直男程序猿的审美），界面动画一多B格自然就上去了。改改图标，贴贴代码的事何乐而不为呢。😹 鼠标点击烟花效果在/themes/主题/source/js目录下新建一个firework.js文件，填入如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&quot;use strict&quot;;function updateCoords(e) { pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top}function setParticuleDirection(e) { var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return { x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) }}function createParticule(e, t) { var a = {}; // 修改粒子大小 return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(12, 24), a.endPos = setParticuleDirection(a), a.draw = function() { ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() }, a}function createCircle(e, t) { var a = {}; return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() { ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 }, a}function renderParticule(e) { for (var t = 0; t &lt; e.animatables.length; t++) { e.animatables[t].target.draw() }}function animateParticules(e, t) { for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) { n.push(createParticule(e, t)) } anime.timeline().add({ targets: n, x: function(e) { return e.endPos.x }, y: function(e) { return e.endPos.y }, radius: 0.1, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule }).add({ targets: a, radius: anime.random(80, 120), // 修改圆圈大小 lineWidth: 0, alpha: { value: 0, easing: &quot;linear&quot;, duration: anime.random(600, 800) }, duration: anime.random(1200, 1800), easing: &quot;easeOutExpo&quot;, update: renderParticule, offset: 0 })}function debounce(e, t) { var a; return function() { var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() { e.apply(n, i) }, t) }}var canvasEl = document.querySelector(&quot;.fireworks&quot;);if (canvasEl) { var ctx = canvasEl.getContext(&quot;2d&quot;), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = &quot;mousedown&quot;, colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;], setCanvasSize = debounce(function() { canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2) }, 500), render = anime({ duration: 1 / 0, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) } }); document.addEventListener(tap, function(e) { &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) }, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)} 可以自行修改颜色和粒子大小。 然后在/themes/主题/layout/layout.jsx文件中加上以下代码： ⚠由于主题不同添加的位置可能不同，一般添加在body标签最后即可 123&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/firework.js&quot;&gt;&lt;/script&gt; 最后效果如下： 是不是非常炫酷呢。","link":"/posts/486003558/"},{"title":"LCP-19 秋叶收藏集","text":"题目回顾 题目详情 小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。 示例 1： 输入：leaves = “rrryyyrryyyrr” 输出：2 解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/UlBDOe 解法思路这题有两种解法，先着重写一下前缀和+动态规划的解法。 要将树叶分成红-黄-红三部分，关键就是要找到2个分界点。不妨将这两个点设为x,y. [0,x-1] 红 [x,y-1] 黄 [y,n-1] 红 那么我们需要操作的次数，就是第一段中黄色的个数、第二段中红色的个数以及第三段中黄色的个数之和，我们的目标就是要找到这个和的最小值。 为了更方便的表示每段中不同颜色的个数，我们可以定义一个前缀和数组， sumR[i]=leaves[0,i]中红色的个数所以需要进行的操作次数可表示为： \\begin{aligned} op=&\\left( x-sumR\\left[ x-1 \\right] \\right) +\\left( sumR\\left[ y-1 \\right] -sumR\\left[ x-1 \\right] \\right) \\\\ &+\\left( \\left( n-y \\right) -\\left( sumR\\left[ n-1 \\right] -sumR\\left[ y-1 \\right] \\right) \\right) \\\\ =&\\left( x-2sumR\\left[ x-1 \\right] \\right) -\\left( y-2sumR\\left[ y-1 \\right] \\right) \\\\ &+n-sumR\\left[ n-1 \\right] \\end{aligned}$n-sumR\\left[ n-1 \\right] $是常数不用管，而观察到x,y相关的表达式形式是统一的，因此不妨令 t[i]=i+1-2*sumR[i]要求op的最小值，就转化为求$t[x]-t[y]$的最小值，或者说，求$t[y]-t[x],(y&gt;x)$的最小值。那么问题就转化成求股票最大差价的问题了，就是一个典型的动态规划问题。 下面需要关心一下x,y的取值范围。 n-1 \\ge y \\ge x+1\\\\ x \\ge 1那么x的范围就是$[1,n-2]$. 因此只需一次遍历t[n]数组，就能得到最大差值。 总体来说，时间复杂度为O(n)，空间复杂度也为O(n)。 代码实现123456789101112131415161718class Solution: def minimumOperations(self, leaves: str) -&gt; int: n=len(leaves) sumR = [0]*n sumR[0]=int(leaves[0]=='r') # 计算 sumR for i in range(1,n): sumR[i]=sumR[i-1]+int(leaves[i]=='r') # 计算 t for i in range(n): t[i]=i+1-2*sumR[i] minT=float(&quot;inf&quot;) max_delta=-float(&quot;inf&quot;) # 计算 max(t[x]-t[y]) for i in range(1,n-1): minT=min(t[i-1],minT) max_delta=max(max_delta,t[i]-minT) return n-sumR[n-1]-max_delta","link":"/posts/3996398217/"},{"title":"LeetCode刷题技巧","text":"春招季过了，在此整理下刷LeetCode题时常用的技巧，以及一些常见题型。 C++/Java/Python 刷题常用技巧C++万能头文件1#include &lt;bits/stdc++.h&gt; 迭代器最大值1*max_element(nums.begin(), nums.end()) 数组大小12345678 // vector nums.size();// arrayint length = sizeof (arr) / sizeof (arr[0]);// 字符串长度str.length() 拷贝数组1copy(tmp.begin(),tmp.end(),dst.begin()); vector合并123456vector&lt;int&gt; vec1 = {...};vector&lt;int&gt; vec2 = {...};// vec1和vec2都存有内容vector&lt;int&gt; vec3;//vec3是空的vec3.insert(vec3.end(),vec1.begin(),vec1.end())//将vec1压入vec3.insert(vec3.end(),vec2.begin(),vec2.end())//继续将vec2压入 vector赋值1234567vector&lt;int&gt; f;f.assign(n, -1);vector&lt;int&gt; ff(n,-1);emplace_back(k,v);push_back(make_pair(k,v)) vector/list 删除12it=vec.begin();vec.erase(it); 列表翻转/求和12std::reverse(v.begin(), v.end());int sum = std::accumulate(v.begin(), v.end(), 0); // init_value=0 string相关1234567891011// 查找string s(&quot;1a2b3c4d5e6f7jkg8h9i1a2b3c4d5e6f7g8ha9i&quot;);position = s.find(&quot;jk&quot;);if (position != s.npos) //如果没找到，返回一个特别的标志c++中用npos表示，我这里npos取值是4294967295，{ printf(&quot;position is : %d\\n&quot; ,position);}// 可用作栈str.pop_back();str.push_back(ch); 字符串分割123456789101112131415161718192021222324252627282930313233// 方法一：检索vector&lt;string&gt; split(const string&amp; str,const string&amp; delim) { //将分割后的子字符串存储在vector中 vector&lt;string&gt; res; if(&quot;&quot; == str) return res; string strs = str + delim; //*****扩展字符串以方便检索最后一个分隔出的字符串 size_t pos; size_t size = strs.size(); for (int i = 0; i &lt; size; ++i) { pos = strs.find(delim, i); //pos为分隔符第一次出现的位置，从i到pos之前的字符串是分隔出来的字符串 if( pos &lt; size) { //如果查找到，如果没有查找到分隔符，pos为string::npos string s = strs.substr(i, pos - i);//*****从i开始长度为pos-i的子字符串 res.push_back(s);//两个连续空格之间切割出的字符串为空字符串，这里没有判断s是否为空，所以最后的结果中有空字符的输出， i = pos + delim.size() - 1; } } return res; }// 方法二：stringstream（只适用于空格等分隔符）vector&lt;string&gt; split_str(string s){ stringstream ss(s); vector&lt;string&gt; words; string word; while(ss&gt;&gt;word){ words.push_back(word); } return words;} sort函数1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;/*sort 对给定区间所有元素进行排序stable_sort 对给定区间所有元素进行稳定排序partial_sort 对给定区间所有元素部分排序partial_sort_copy 对给定区间复制并排序nth_element 找出给定区间的某个位置对应的元素is_sorted 判断一个区间是否已经排好序partition 使得符合某个条件的元素放在前面stable_partition 相对稳定的使得符合某个条件的元素放在前面*/int arr[] = { 2, 4, 5, 3, 1 };sort(arr, arr + 5, greater&lt;int&gt;());#include&lt;qsort&gt;void qsort(void *base,int nelem,int width,int (*fcmp)(const void *,const void *));/*1 待排序数组首地址2 数组中待排序元素数量3 各元素的占用空间大小4 指向函数的 指针，用于确定排序的顺序*/// 排序索引template &lt;typename T&gt;std::vector&lt;int&gt; sort_indexes(const std::vector&lt;T&gt; &amp;v) { // 初始化索引向量 std::vector&lt;int&gt; idx(v.size()); //使用iota对向量赋0~？的连续值 std::iota(idx.begin(), idx.end(), 0); // 通过比较v的值对索引idx进行排序 //NOTE: lambda函数 auto fun = [捕获参数](函数参数){函数体}; std::sort(idx.begin(), idx.end(), [&amp;v](int i1, int i2) { return v[i1] &lt; v[i2]; }); return idx;} 全排列123456789#include &lt;algorithm&gt;bool next_permutation(iterator start,iterator end);//当序列不存在下一个排列时，函数返回false，否则返回true// 需要先按升序排序！！！！do { cout&lt;&lt;num[0]&lt;&lt;&quot; &quot;&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;endl; }while(next_permutation(num,num+3)); unordered_set12345insert() //向容器中添加新元素。erase() //删除指定元素。clear() //清空容器，即删除容器中存储的所有元素。myset.find(x) != myset.end() //存在myset.count(x) multiset(可以保存重复元素)红黑树实现，默认升序 123456#include &lt;set&gt;st.erase(x) // 删除所有值为x的项st.erase(myset.find(x)) // 删除一个st.upper_bound(20); // 返回 iterator，未找到 multiset::end*it 取值 map查询元素是否存在12345678910111213141516// 使用 find() 函数检查元素是否存在auto it = mymap.find(&quot;a&quot;);if (it != mymap.end()) { // 元素存在} else { // 元素不存在}// 使用 count() 函数检查元素是否存在int count = mymap.count(&quot;a&quot;);if (count &gt; 0) { // 元素存在} else { // 元素不存在} map遍历12345678910for (auto&amp; [first, second] : mp){}// ormap&lt;int, int&gt;::iterator iter;iter = _map.begin();while(iter != _map.end()) { cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; iter++;} tie批量赋值1tie(dp0,dp1)=make_tuple(min(dp0,dp1)+cost[i],min(dp0,dp1+cost[i-1])); 优先队列123456789101112131415161718192021222324252627/*定义：priority_queue&lt;Type, Container, Functional&gt;Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆*/#include &lt;queue&gt;//升序队列，小顶堆priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列，大顶堆priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;q.empty() //如果队列为空，则返回true，否则返回falseq.size() //返回队列中元素的个数q.pop() //删除队首元素，但不返回其值q.top() //返回具有最高优先级的元素值，但不删除该元素q.push(item); //在基于优先级的适当位置插入新元素 // 自定义排序规则auto cmp = [](const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) { return a.second == b.second ? a.first &lt; b.first : a.second &gt; b.second; };priority_queue&lt;pair&lt;string, int&gt;, vector&lt;pair&lt;string, int&gt;&gt;, decltype(cmp)&gt; que(cmp); 双端队列12345678#include &lt;deque&gt;deque&lt;int&gt; dq1(8);deque&lt;int&gt; dq1(8,0);push_back();push_front();back();front(); 二分查找123456789101112131415int search(vector&lt;int&gt;&amp; nums, int target) { int l=0; int r=nums.size()-1; while(l&lt;=r){ int mid=(l+r)/2; if(nums[mid]&gt;target){ r=mid-1; }else if(nums[mid]&lt;target){ l=mid+1; }else{ return mid; } } return -1;} 1234// STL 二分查找排好序的数组lower_bound( begin,end,num) // 第一个大于或等于num的数字upper_bound( begin,end,num) // 第一个大于num的数字lower_bound( vec.begin(),vec.end(),num,greater&lt;type&gt;() ) // 第一个小于或等于num的数字 子集123456789101112131415161718192021222324252627282930313233// 二进制掩码vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; t; vector&lt;vector&lt;int&gt;&gt; ans; int n = nums.size(); for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) { t.clear(); for (int i = 0; i &lt; n; ++i) { if (mask &amp; (1 &lt;&lt; i)) { t.push_back(nums[i]); } } ans.push_back(t); } return ans;}// 迭代vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { int n=nums.size(); vector&lt;vector&lt;int&gt;&gt; res(1,vector&lt;int&gt;()); for(auto i:nums){ vector&lt;vector&lt;int&gt;&gt; tmp; for(auto &amp;pre:res){ vector&lt;int&gt; t=pre; t.push_back(i); tmp.push_back(t); } res.insert(res.end(),tmp.begin(),tmp.end()); } return res;} 二分图最大匹配12345678910111213141516171819202122232425262728293031323334353637383940414243struct Edge{ int from; int to; int weight; Edge(int f, int t, int w):from(f), to(t), weight(w) {}};vector&lt;int&gt; G[__maxNodes]; // G[i] 存储顶点 i 出发的边的编号 int matching[__maxNodes]; /* 存储求解结果 */int check[__maxNodes]; // 标志位bool dfs(int u){ for (iterator_t i = G[u].begin(); i != G[u].end(); ++i) { // 对 u 的每个邻接点 int v = edges[*i].to; if (!check[v]) { // 要求不在交替路中 check[v] = true; // 放入交替路 if (matching[v] == -1 || dfs(matching[v])) { // 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功 matching[v] = u; matching[u] = v; return true; } } } return false; // 不存在增广路，返回失败}int main(){ int ans = 0; memset(matching, -1, sizeof(matching)); for (int u=0; u &lt; num_left; ++u) { if (matching[u] == -1) { memset(check, 0, sizeof(check)); // 清除标志位 if (dfs(u)) ++ans; } } return ans;} 位运算技巧123n&amp;1; // 取最低位n&amp;(n-1); // 去除最低位的 1 （若n为2的幂，结果为0）n&amp;(-n); //只取最低位的 1 （若n为2的幂，结果为n） JavaString相关1234567891011121314public static void string_test() { String s1 = new String(&quot;abc123 321 q w 测试 p&quot;); System.out.println(s1); String s2 = s1.substring(3, 6); System.out.println(s2); String[] ss = s1.split(&quot; &quot;); // 字符串分割 System.out.printf(&quot;the second part is: %s\\n&quot;, ss[1]); System.out.println(Arrays.toString(ss)); // 输出列表 // str -&gt; int int i1 = Integer.parseInt(s2); Integer i2 = Integer.valueOf(s2); } 数组相关 123456789101112131415161718192021 public static void array_test() { Integer[] a = {1,3,2,4,10,5}; Arrays.sort(a); System.out.println(a.length); Arrays.sort(a, Collections.reverseOrder()); // 必须用包装类 // Comparator&lt;Integer&gt; myCom = new CMP(); // Arrays.sort(a, myCom); System.out.println(Arrays.toString(a)); }// 自定义比较函数class CMP implements Comparator&lt;Integer&gt;{ @Override //可以去掉。作用是检查下面的方法名是不是父类中所有的 public int compare(Integer a,Integer b){// 两种都可以，升序排序的话反过来就行// return a-b&lt;0?1:-1; return b-a; }} 数组求和1Arrays.stream(array).sum(); Python输入 输入一行 1listt=map(lambda x:int(x),raw_input().split()) 输入N行 1234567n = input()def f(x): if ord(x[0]) &lt; 58: # 判断是数字还是字母 return int(x) return xa = [map(f, raw_input().split()) for i in range(n)]a=[map(lambda x:int(x) if ord(x[0])&lt;58 else x,raw_input().split())for i in range(n)] 多样例输入（EOF） 1234import sys for line in sys.stdin: print int(line)**2# pow(3,2,4) == 3**2%4 输出 字符串拼接输出 1234strr = '' # 创建一个空字符串for i in listt: strr += i # 依次添加 i，若是数字，记得换为str(i)print strr 一行输出列表 1print str(a).replace(', ',' ').replace('\\'','')[1:-1]+' ' 一些算法基数排序12345678910111213141516171819202122232425262728void radixSort(vector&lt;int&gt;&amp; nums){ int maxVal = *max_element(nums.begin(),nums.end()); int len = nums.size(); vector&lt;int&gt; tmp(len); int exp=1; while(maxVal&gt;=exp){ // 相当于10个指针，记录下标位置 vector&lt;int&gt; cnt(10); // 统计每个桶中元素个数 for(int i=0;i&lt;len;i++){ int mod=nums[i]/exp%10; cnt[mod]++; } // 计算每个桶的下标结束位置 for(int i=1;i&lt;10;i++){ cnt[i]+=cnt[i-1]; } // 填充新元素 for(int i=len-1;i&gt;=0;i--){ int mod=nums[i]/exp%10; tmp[cnt[mod]-1]=nums[i]; cnt[mod]--; } exp*=10; copy(tmp.begin(),tmp.end(),nums.begin()); } } 并查集12345678910111213141516171819202122232425262728inline void init(int n){ for (int i = 1; i &lt;= n; ++i) { fa[i] = i; // 父节点 rank[i] = 1; // 深度 }}int find(int x){ if(x == fa[x]) return x; else{ fa[x] = find(fa[x]); //递归找父亲的父亲设为根节点 return fa[x]; //返回父节点 } // return x == fa[x] ? x : (fa[x] = find(fa[x])); // 精简形式}inline void merge(int i, int j){ int x = find(i), y = find(j); if (rank[x] &lt;= rank[y]) // 深度大的做根节点 fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) // 深度相同时，新根节点深度+1 rank[y]++;} 快排12345678910111213141516171819202122void quickSort(int[] s, int l, int r){ if(l&gt;=r)return; int i = l, j = r, x = s[l]; while(i&lt;j){ while(i&lt;j&amp;&amp;s[j]&gt;=x){ j--; } if(i&lt;j){ // 第一位取出来了，所以可以放进去 s[i++]=s[j]; } while(i&lt;j&amp;&amp;s[i]&lt;x){ i++; } if(i&lt;j){ s[j--]=s[i]; } } // i==j时出来 s[i]=x; // 再把标准值放回中间 quickSort(s,l,i-1); quickSort(s,i+1,r);} 背包问题01背包问题 容量为10的背包，有5种物品，每种物品只有一个，其重量分别为5，4，3，2，1，其价值分别为1，2，3，4，5。设计算法，实现背包内物品价值最大。（输出14） 123456789101112131415int main() { int total_weight = 10; int w[6] = { 0,5,4,3,2,1}; int v[6] = { 0,1,2,3,4,5}; int dp[11] = { 0 }; for (int i = 1; i &lt;= 5; i++) for (int j = 10; j &gt;= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i]] + v[i]); cout &lt;&lt; &quot;总的价值为: &quot; &lt;&lt; dp[10] &lt;&lt; endl; return 0;} 完全背包问题 容量为10的背包，有5种物品，每种物品数量无限，其重量分别为5，4，3，2，1，其价值分别为1，2，3，4，5。设计算法，实现背包内物品价值最大。（输出50） 1234567891011121314int main() { int total_weight = 10; int w[6] = { 0,5,4,3,2,1}; int v[6] = { 0,1,2,3,4,5}; int dp[11] = { 0 }; for (int i = 1; i &lt;= 5; i++) for (int j = w[i]; j &lt;= 10;j++) dp[j] = max(dp[j],dp[j - w[i]] + v[i]); cout &lt;&lt; &quot;总的价值为: &quot; &lt;&lt; dp[10] &lt;&lt; endl; return 0;} 多重背包问题 容量为10的背包，有5种物品，每种物品数量分别为1，2，1，2，1，其重量分别为5，4，3，2，1，其价值分别为1，2，3，4，5。设计算法，实现背包内物品价值最大。（输出16） 12345678910111213141516int main(){ int total_weight = 10; int w[6] = { 0,5,4,3,2,1 }; int v[6] = { 0,1,2,3,4,5 }; int cot[6] = { 0,1,2,1,2,1 }; int dp[11] = { 0 }; for (int i = 1; i &lt;= 5; i++) for (int k = 1; k &lt;= cot[i];k++) for (int j = 10; j &gt;= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i]] + v[i]); cout &lt;&lt; &quot;总的价值为: &quot; &lt;&lt; dp[10] &lt;&lt; endl; return 0;} 子集1234567891011121314151617181920212223242526272829303132333435363738vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { int n=nums.size(); vector&lt;vector&lt;int&gt;&gt; res(1,vector&lt;int&gt;()); for(auto i:nums){ vector&lt;vector&lt;int&gt;&gt; tmp; for(auto &amp;pre:res){ // 每个结果都加上当前数 vector&lt;int&gt; t=pre; t.push_back(i); tmp.push_back(t); } res.insert(res.end(),tmp.begin(),tmp.end()); } return res;}// 回溯法class Solution {public: vector&lt;int&gt; t; vector&lt;vector&lt;int&gt;&gt; ans; void dfs(int cur, vector&lt;int&gt;&amp; nums) { if (cur == nums.size()) {// 记录答案 ans.push_back(t); return; } t.push_back(nums[cur]); dfs(cur + 1, nums);// 考虑选择当前位置 t.pop_back(); dfs(cur + 1, nums);// 考虑不选择当前位置 } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { dfs(0, nums); return ans; }}; ST表 ST表（Sparse Table，稀疏表）是一种简单的数据结构，主要用来解决RMQ（Range Maximum/Minimum Query，区间最大/最小值查询）问题。它主要应用倍增的思想，可以实现 O(nlogn)预处理、 O(1)查询。 ST表使用一个二维数组dp[i][j]，表示(i, i + 2^j - 1)范围内的最大值。 递推式 dp[i][j] = max(dp[i][j-1],dp[i+ 2^j][j-1]) 对于每个询问(l, r) ，我们把它分成两部分：[l, l+ 2^s -1]与[r-2^s +1,r] 。 其中 s=floor(log(r-l+1))。 模板 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int logn = 21;const int maxn = 2000001;int f[maxn][logn + 1], Logn[maxn + 1];inline int read() { char c = getchar(); int x = 0, f = 1; while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -1; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x * 10 + c - '0'; c = getchar(); } return x * f;}void pre() { Logn[1] = 0; Logn[2] = 1; for (int i = 3; i &lt; maxn; i++) { Logn[i] = Logn[i / 2] + 1; }}int main() { int n = read(), m = read(); for (int i = 1; i &lt;= n; i++) f[i][0] = read(); pre(); for (int j = 1; j &lt;= logn; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); for (int i = 1; i &lt;= m; i++) { int x = read(), y = read(); int s = Logn[y - x + 1]; printf(&quot;%d\\n&quot;, max(f[x][s], f[y - (1 &lt;&lt; s) + 1][s])); } return 0;} 一些例题问题简化——移项n=5x+2y+z，x,y,z为非负整数，给出一个n，求x,y,z的取值情况数。 朴素解法 n^3 x 0~n/5 y 0~n/2 z 0~n 移项，等号变不等号，复杂度降为 n^2 n-z = 5x+2y &gt;=0 只需遍历 x,y 寻找数学规律，降为O(n) 这次把5x移过来 n-5x=2y+z=k 先观察上式等于k时，y,z的取值有 floor(k/2)+1(即y可区从0到k/2) 那么对于每个x的取值，只需O(1)即可求解出答案，x从0遍历至n/5，复杂度为O(n). 终极优化O(1)！！！ 经过上一步，已经不难发现其实答案时个等差数列求和，所以只需代入前3项即可求出二次多项式。 最大公约数辗转相除法 a=a%b swap(a,b) 直到b==0 swap终极优化版 b=b xor a a=a xor b b=b xor a （异或2次等于本身） 12345// 终极简化版int gcd(int a,int b){ while(b^=a^=b^=a%=b); return a;} LRU（最近最少使用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct Node { int key, value; Node* last; Node* next; Node(int k=0, int v=0): key(k), value(v), last(nullptr), next(nullptr) {}};class LRUCache {private: unordered_map&lt;int, Node*&gt; cache; Node* head; Node* tail; int size; int capacity; //容量public:// tail &lt;-next-- head LRUCache(int _capacity): capacity(_capacity), size(0) { // 使用伪头部和伪尾部节点 head = new Node(); tail = new Node(); head-&gt;next = tail; tail-&gt;last = head; } int get(int key) { if (!cache.count(key)) { return -1; } // 如果 key 存在，先通过哈希表定位，再移到头部 Node* node = cache[key]; moveToHead(node); return node-&gt;value; } void put(int key, int value) { if (!cache.count(key)) { // 如果 key 不存在，创建一个新的节点 Node* node = new Node(key, value); // 添加进哈希表 cache[key] = node; // 添加至双向链表的头部 addToHead(node); ++size; if (size &gt; capacity) { // 如果超出容量，删除双向链表的尾部节点 removeNode(tail-&gt;last); --size; } } else { // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部 Node* node = cache[key]; node-&gt;value = value; moveToHead(node); } } void addToHead(Node* node) { node-&gt;last = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;last = node; head-&gt;next = node; } void removeNode(Node* node) { node-&gt;last-&gt;next = node-&gt;next; node-&gt;next-&gt;last = node-&gt;last; cache.erase(node-&gt;key);// 删除哈希表中对应的项 delete node; } void moveToHead(Node* node) { node-&gt;last-&gt;next = node-&gt;next; node-&gt;next-&gt;last = node-&gt;last; addToHead(node); }}; LFU （最不经常使用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct Node { int key, value, freq; Node* last; Node* next; Node(int k=-1, int v=-1): key(k), value(v), last(nullptr), next(nullptr), freq(1) {}};class FreqList{public: Node* head; Node* tail; int size; FreqList():size(0){ head = new Node(); tail = new Node(); head-&gt;next = tail; tail-&gt;last = head; } void addToHead(Node* node) { node-&gt;last = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;last = node; head-&gt;next = node; size++; } void removeNode(Node* node){ node-&gt;last-&gt;next = node-&gt;next; node-&gt;next-&gt;last = node-&gt;last; size--; } // 删除最后，返回key int removeTail(){ int k=-1; // if(size&gt;0){ Node* node=tail-&gt;last; k=node-&gt;key; removeNode(node); delete node; // } return k; }};class LFUCache {private: unordered_map&lt;int, Node*&gt; cache; unordered_map&lt;int, FreqList*&gt; freqMap; // 频率 int minFreq; int size; int capacity; //容量public: LFUCache(int _capacity): capacity(_capacity),size(0),minFreq(1){ } int get(int key) { if(cache.count(key)){ Node* node = cache[key]; freqMap[node-&gt;freq]-&gt;removeNode(node); //remove node-&gt;freq++; if(!freqMap.count(node-&gt;freq))freqMap[node-&gt;freq]=new FreqList(); freqMap[node-&gt;freq]-&gt;addToHead(node); // add to [freq+1] return node-&gt;value; }else{ return -1; } } void put(int key, int value) { if(capacity==0)return; if(cache.count(key)){ Node* node = cache[key]; freqMap[node-&gt;freq]-&gt;removeNode(node); //remove node-&gt;value=value; node-&gt;freq++; if(!freqMap.count(node-&gt;freq))freqMap[node-&gt;freq]=new FreqList(); freqMap[node-&gt;freq]-&gt;addToHead(node); // add to [freq+1] cache[key]=node; }else{ Node* node = new Node(key,value); if(size==capacity){ while(freqMap[minFreq]-&gt;size==0)minFreq++; cache.erase(freqMap[minFreq]-&gt;removeTail()); // delete freqMap[minFreq]; size--; } cache[key]=node; if(!freqMap.count(node-&gt;freq))freqMap[node-&gt;freq]=new FreqList(); freqMap[node-&gt;freq]-&gt;addToHead(node); // add to [1] minFreq=1; size++; } }};","link":"/posts/1993660772/"},{"title":"LCP-992 K个不同整数的子数组","text":"题目回顾 题目详情 给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。 （例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。） 返回 A 中好子数组的数目。 示例 1： 123输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. 示例 2： 123输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]. 提示： 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= A.length 1 &lt;= K &lt;= A.length Discussion | Solution 解法思路滑动窗口月当然还是用滑动窗口的方法。这题乍一看挺简单，随手就敲了一个$O(n^2)$的双指针遍历方法。果然就卡在了超时上了。 要降低时间复杂度就要让指针不回头，但这时还要找到所有恰好有K种整数的情况并不容易。我们不妨转化下问题，要找到符合条件最长的子串是可以一次遍历求解的。那么一个包含K种数字的最长子串的所有子串均包含$\\le K$种数字。 因此可以定义一个函数getMostDistinct(A, K)求得含$\\le K$种数字的子串个数，那恰好为K个的情况就等于getMostDistinct(A, K)-getMostDistinct(A, K-1) 思路总结：直接求等不好求的时候，可以将等号条件转化为两个不等关系相减 代码实现123456789101112131415161718192021222324252627282930313233343536373839/* * @lc app=leetcode.cn id=992 lang=cpp * * [992] K 个不同整数的子数组 */// @lc code=startclass Solution {public: int getMostDistinct(vector&lt;int&gt;&amp; A, int K){ int l=0,r=0; int size=A.size(); int* st=new int[size+1](); int cnt=0; int res=0; while(r&lt;size){ if(st[A[r]]==0){ cnt++; } st[A[r]]++; r++; while(cnt&gt;K){ st[A[l]]--; if(st[A[l]]==0){ cnt--; } l++; } res+=r-l; } return res; } int subarraysWithKDistinct(vector&lt;int&gt;&amp; A, int K) { return getMostDistinct(A,K)-getMostDistinct(A,K-1); }};// @lc code=end 时间复杂度O(n) 2 2还是O(n)","link":"/posts/2518194438/"},{"title":"Linux 主机初始化环境配置","text":"为了方便以后迁移主机，记录下Linux主机迁移后必要的初始化操作 配置SSH免密登录 使用powershell等等终端使用密码登录ssh 1ssh root@xx.xx.xx.xx 首次登录会出现认证确认，输入yes即可，随后输入密码。 生成公钥和私钥 1ssh-keygen -t rsa 直接按回车就行 导入公钥到认证文件,更改权限 在服务器的/root/.ssh路径下新建authorized_keys文件，输入你控制端的公钥。 Windows的ssh配置文件在C:/用户/.ssh下 用记事本打开id_rsa.pub，注意！一定是.pub！ 注意！一定是.pub！ 注意！一定是.pub！ 把里面的内容复制到服务器的authorized_keys文件中 更改权限（这一步非常重要！不然你配置都正确还是无法免密登录！） 123# 更改主机配置文件权限chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 一键连接脚本 现在就能新建一个文本文件输入以下内容，把后缀改成.bat(cmd)或ps1(powershell)，就能够一键启动啦！ 1ssh root@xx.xx.xx.xx PS. 如果你想用更美观的powershell启动，.ps1文件默认双击是打开编辑，只能右击运行。或者还有种办法可以曲线救国： 新建一个cmd脚本，输入： 1start powershell -c &quot;ssh root@xx.xx.xx.xx&quot; 就能双击用cmd启动powershell啦！（强迫症表示非常舒适 Linux 永久修改DNS123vi /etc/sysconfig/network-scripts/ifcfg-eth0&gt;&gt; DNS1=8.8.8.8&gt;&gt; DNS2=1.0.0.1 重启生效。 查看当前DNS设置 1cat /etc/resolv.conf 当然如果只需要临时修改DNS，直接修改vi /etc/resolv.conf也可以（重启恢复） 服务器测试脚本ZBench 1wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/ZBench/master/ZBench-CN.sh &amp;&amp; bash ZBench-CN.sh superbench 1wget -qO- git.io/superbench.sh | bash 91Yun自定义测试包 https://www.91yuntest.com/ 安装必要程序 screen 1yum install screen JRE 1yum install java-11-openjdk Miniconda(方便配置Python3环境) 1wget -N https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh &amp;&amp; bash Miniconda3-latest-Linux-x86_64.sh BBR/BBR plus/锐速 1bash &lt;(curl -Ls https://github.com/cx9208/Linux-NetSpeed/raw/master/tcp.sh) V2-ui 1bash &lt;(curl -Ls https://blog.sprov.xyz/v2-ui.sh) /etc/v2-ui x-ui 1bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) aria2 1yum install aria2 -y Web可视化界面 AriaNg 详见→ FileBrowser(在线文件管理) 1curl -fsSL https://raw.githubusercontent.com/filebrowser/get/master/get.sh | bash 启动命令 1./filebrowser -p 8009 -r /path/to/your/files 开机自启，配置service 1234567891011121314151617[Unit]Description=FilebrowserAfter=network.targetWants=network.target[Service]WorkingDirectory=/root/server/fileserverExecStart=/usr/local/bin/filebrowser -p 8009 -r /pathRestart=on-abnormalRestartSec=5sKillMode=mixedStandardOutput=nullStandardError=syslog[Install]WantedBy=multi-user.target cloudreve 一个功能很强大的私有网盘平台 Nginx 反代配置为了安全起见，服务器应尽可能少开放端口。以上各种服务均可通过Nginx反向代理本地端口实现。 对于文件服务器的反代配置如下： 1234567891011121314151617location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; # 将域名转发至本地端口 proxy_pass http://127.0.0.1:8009; # 启用分片加载（在线播放视频可以缓冲，该功能可能需要重新编译nginx，见下文），缓存大小自行调整 slice 5m; proxy_set_header Range $slice_range; proxy_set_header If-Range $http_if_range; # 缓存策略 proxy_cache_key $scheme$host$request_uri$slice_range; # 最大上传文件尺寸 client_max_body_size 20000m;} 宝塔安装的nginx默认没有开启slice功能，因此需要手动加上--with-http_slice_module编译参数。 nginx -V查看当前nginx的编译参数，检查是否开启了--with-http_slice_module功能： 123456&gt; nginx -Vnginx version: nginx/1.21.4built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)built with OpenSSL 1.1.1q 5 Jul 2022TLS SNI support enabledconfigure arguments: --user=www --group=www --prefix=/www/server/nginx --add-module=/www/server/nginx/src/ngx_devel_kit --add-module=/www/server/nginx/src/lua_nginx_module --add-module=/www/server/nginx/src/ngx_cache_purge --add-module=/www/server/nginx/src/nginx-sticky-module --with-openssl=/www/server/nginx/src/openssl --with-pcre=pcre-8.43 --with-http_v2_module --with-stream --with-stream_ssl_module --with-stream_ssl_preread_module --with-http_stub_status_module --with-http_ssl_module --with-http_image_filter_module --with-http_gzip_static_module --with-http_gunzip_module --with-ipv6 --with-http_sub_module --with-http_flv_module --with-http_addition_module --with-http_realip_module --with-http_mp4_module --with-ld-opt=-Wl,-E --with-cc-opt=-Wno-error --with-ld-opt=-ljemalloc --with-http_dav_module --add-module=/www/server/nginx/src/nginx-dav-ext-module 若没有，则先停止nginx： 1systemctl stop nginx 然后进入nginx源码目录： 1cd /www/server/nginx/src 设置编译参数（把上面nginx -V 的结果复制下来，加上--with-http_slice_module） 1./configure --user=www --group=www --prefix=/www/server/nginx --add-module=/www/server/nginx/src/ngx_devel_kit --add-module=/www/server/nginx/src/lua_nginx_module --add-module=/www/server/nginx/src/ngx_cache_purge --add-module=/www/server/nginx/src/nginx-sticky-module --with-openssl=/www/server/nginx/src/openssl --with-pcre=pcre-8.43 --with-http_v2_module --with-stream --with-stream_ssl_module --with-stream_ssl_preread_module --with-http_stub_status_module --with-http_ssl_module --with-http_image_filter_module --with-http_gzip_static_module --with-http_gunzip_module --with-ipv6 --with-http_sub_module --with-http_flv_module --with-http_addition_module --with-http_realip_module --with-http_mp4_module --with-ld-opt=-Wl,-E --with-cc-opt=-Wno-error --with-ld-opt=-ljemalloc --with-http_dav_module --with-http_slice_module --add-module=/www/server/nginx/src/nginx-dav-ext-module 编译安装 1make &amp;&amp; make install Python环境Condaminiconda：https://docs.conda.io/en/latest/miniconda.html#linux-installers 12wget https://repo.anaconda.com/miniconda/Miniconda3-py39_23.1.0-1-Linux-x86_64.shbash Miniconda3-py39_23.1.0-1-Linux-x86_64.sh 换源 12345678vim ~/.condarcchannels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ssl_verify: true 创建环境 1conda create -n torch1.13 python=3.9 Pip换源 1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple","link":"/posts/4179222363/"},{"title":"MySQL数据库搭建","text":"MySQL安装 安装信息 操作系统：centos8 MySQL版本：8.0.19 安装方式：rpm 安装 上传安装文件到服务器 使用root用户安装，自动创建mysql用户 客户端 123rpm -ivh mysql-community-common-8.0.19-1.el8.x86_64.rpm rpm -ivh mysql-community-libs-8.0.19-1.el8.x86_64.rpmrpm -ivh mysql-community-client-8.0.19-1.el8.x86_64.rpm 服务端 1rpm -ivh mysql-community-server-8.0.19-1.el8.x86_64.rpm 初始化 mysqld —initialize 修改用户组 chown -R mysql:mysql /var/lib/mysql 检查进程状态 systemctl status mysqld 启动 systemctl start mysqld 查看root密码 cat /var/log/mysqld.log | grep password2020-07-06T06:18:47.050833Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: kaUb3H9p!OlG MySQL安全配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960mysql_secure_installation Securing the MySQL server deployment. Enter password for user root: The existing password for the user account root has expired. Please set a new password. New password: Re-enter new password: VALIDATE PASSWORD COMPONENT can be used to test passwords and improve security. It checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD component? Press y|Y for Yes, any other key for No: no Using existing password for root. Change the password for root ? ((Press y|Y for Yes, any other key for No) : no ... skipping. By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? (Press y|Y for Yes, any other key for No) : y Success. Normally, root should only be allowed to connect from 'localhost'. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? (Press y|Y for Yes, any other key for No) : no ... skipping. By default, MySQL comes with a database named 'test' that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database... Success. - Removing privileges on test database... Success. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y Success. All done! 检查客户端连接 123456789101112131415161718192021222324252627mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 11 Server version: 8.0.19 MySQL Community Server - GPL Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; 设置Mysql数据库root密码 123mysql&gt; use mysqlmysql&gt; update user set authentication_string='' where user = 'root';mysql&gt; alter user 'root'@'localhost' identified by 'Root@123'; 测试新密码是否生效： 1234567891011121314151617mysql&gt; exit# mysql -uroot -p Enter password: [输入新设置的密码]Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 12Server version: 8.0.19 MySQL Community Server - GPL Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql&gt; 开启MySQL远程访问 一般情况不允许，不安全 连接mysql服务器 123456789101112131415mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select user,host from user;+------------------+-----------+| user | host |+------------------+-----------+| mysql.infoschema | localhost || mysql.session | localhost || mysql.sys | localhost || root | localhost |+------------------+-----------+4 rows in set (0.00 sec) 更新user表中的localhost为“%” 1mysql&gt; update user set host='%' where user = 'root'; root用户授权 12msyql&gt; alter user 'root'@'%' identified with mysql_native_password by 'Root@123';mysql&gt; flush privileges; 测试远程连接 1mysql -h 192.168.1.103 -uroot -p 数据库客户端工具测试 Navicat DataGrip HeidiSQL(开源) MySQL官方工具 MySQL存储引擎 MyISAM：不支持事务，查询速度快 InnoDB：默认存储引擎，全事务支持引擎 Memory：内存存储引擎，速度太快 导入SQL脚本 1234mysql&gt; create database world;mysql&gt; use worldmysql&gt; source /root/tools/MySQL-8.0.19/world.sqlmsyql&gt; show tables; 1234567891011121314mysql&gt; show create table city\\G*************************** 1. row ***************************Table: cityCreate Table: CREATE TABLE `city` (`ID` int NOT NULL AUTO_INCREMENT,`Name` varchar(40) NOT NULL DEFAULT '',`CountryCode` varchar(5) NOT NULL DEFAULT '',`District` varchar(30) NOT NULL DEFAULT '',`Population` int NOT NULL DEFAULT '0',PRIMARY KEY (`ID`)) ENGINE=MyISAM AUTO_INCREMENT=4080 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci1 row in set (0.00 sec)mysql&gt;","link":"/posts/2429243691/"},{"title":"Paxos分布式理论学习","text":"当有一系列提议者提出值时，为保证一致性，需要满足以下条件： 被选中的值必须是已经被提出的 每次只能有一个值被选中 一个值真实被选中前，不可提前知道结果 协议成员Proposer：提议发起者 Acceptor：提议接受者 Learner：提议学习者，Learner角色的目的就是把通过的确定性取值同步给其他未确定的Acceptor。 协议过程阶段一：a) Proposer选择一个提议编号n，并向所有Acceptor广播prepare(n)消息 graph LR P1--\"prepare(n)\"-->A1 P1--\"prepare(n)\"-->A2 P1--\"prepare(n)\"-->A3 b) 如果Acceptor收到的提议编号大于之前已经回复过的prepare消息编号，那么将回应不会再接收比n小的消息，并带上之前所接受过的最大编号 graph RL A1--\"promise(n,{n1,v1})\"-->P1 A2--\"promise(n,{n2,v2})\"-->P1 A3--\"promise(n)\"-->P1 note[\"A1之前接受过最大的为n1，A2之前接受过最大的为n2，A3未接受过(n>n1>n2)\"] 阶段二：a) Proposer得到了多数Acceptor的承诺后，那么向所有的Acceptor发起编号为n的提议，提议的值为所有回应中最大的编号所对应的值，否则发送自己新提议的值。 graph LR P1--\"accept(n,v1)\"-->A1 P1--\"accept(n,v1)\"-->A2 P1--\"accept(n,v1)\"-->A3 note[\"由于之前回应中最大提议编号为n1，所以发送的值为v1\"] b) Acceptor如果没有回复过比n大的prepare消息，则接受该提议。","link":"/posts/3438488174/"},{"title":"最优化问题求解及Lingo教程","text":"介绍Lingo是一款求解最优化问题的软件，可以用于求解非线性规划，也可以用于一些线性和非线性方程组的求解等，功能十分强大，是求解优化模型的最佳选择。 LINGO与MATLAB比较 MATLAB 语法严谨，模型必须是标准形式 内置算法只支持一维下标决策变量 对于大规模问题，描述方式复杂、不直观 求解NLP问题需要给出合适的初值估计 需要自己制定算法 LINGO 模型可以不是标准形式 支持二维下标决策变量 大规模问题，运用集合命令可以方便定义带有规律的多个复杂条件 求解NLP问题不需要给出初值估计 不需要熟悉、指定算法 最优化问题首先介绍一下什么是最优化问题。 最优化问题，即在所有可行的方案中选出使得目标最优的方案的实际问题。 优化问题的三要素是： 决策变量 约束条件 目标函数 数学规划/函数优化问题的标准形式 \\min/ \\max f(x)\\\\ s.t. g_i(x)\\leq0,i=1,\\dots,m_1\\\\ h_j(x)=0,j=1,\\dots,m_2\\\\ f:D \\rightarrow R,D \\subseteq R^n 优化问题分类根据决策变量取值情况不同，分为连续型和离散型。 根据有无约束条件分为无约束优化和带约束优化。 根据处理思想方法不同，分为数学规划（函数优化问题）、组合优化、图论与网络流、动态规划、目标优化、模糊优化、随机优化、对策与决策…… Lingo教程求解LP问题 \\min=2*x_1+3*x_2\\\\ s.t. x_1+x_2 \\geq 350\\\\ x_1 \\geq 100\\\\ 2*x_1+x_2 \\leq 600求解这样一个问题，只需直接输入如下代码，写法基本与数学公式一直，不用改写成标准形式 1234min=2*x1+3*x2;x1+x2&gt;=350;x1&gt;=100;2*x1+x2&lt;=600; 点击🎯图标运行： 可以看到直接识别出了问题类型，并找到了全局最优解。 求解MILP问题 @free: 可正可负（默认大于等于0） @gin：整数 求解IQP问题⚠一定要在Lingo选项-&gt;求解非线性菜单中勾选二次规划识别！！否则会按照INLP问题求解,只能得出局部最优解。 1234max=98*x1+277*x2-x1^2-0.3*x1*x2-2*x2^2;x1+x2&lt;=100;x1&lt;2*x2;@gin(x1);@gin(x2); 运算符 算数运算符 + - * / ^ 关系运算符 &lt;(=) = &gt;(=) 逻辑运算符 否定 #NOT# 相等 #EQ# 不等 #NE# 与 #AND# 或 #OR# 大于 #GT# 大于等于 #GE# 小于等于 #LE# 小于 #LT# 数学函数 @ABS(x) 绝对值 @SIN(x)，@COS(x) … 三角函数 @EXP(x) 返回$e^x$ @LOG(x) 自然对数 @SIGN(x) x&lt;0返回-1；否则返回1 @FLOOR(x) 返回x靠近0的整数部分，如@FLOOR(1.2)=1,@FLOOR(-2.3)=-2 金融函数 $@fpa(r,n)=\\sum_{k=1}^n{\\frac{1}{\\left( 1+r \\right) ^k}=}\\frac{1-\\left( 1+r \\right) ^{-n}}{r}$ $@fpl(r,n)=\\left( 1+r \\right) ^{-n}$ 概率函数 @pbn(p,n,x) 二项分布 @pcx(n,x) 卡方分布 @pfd(n,d,x) F分布 …… 变量界定函数Lingo变量默认是非负的 @bin(x) x=0或1 @bnd(L,x,U) $L \\le x \\le U$ free(x) 实数 @gin(x) 整数 条件判断函数@IF(logical_condition,true_result,false_result) 例：分段函数 f\\left( x \\right) =\\begin{cases} 100,x>0\\\\ 2x, x\\le 0\\\\ \\end{cases}fx=@if(x #gt# 0,100,2*x) 集合操作函数 @in(set_name,index_1[,index_2]) 是否在集合中，返回0/1 @wrap(index,limit) 取模，返回 j=index-k*limit=index(mod limit) +1, k为整数，保证j在[1, limit]内 @size(set_name) 集合成员个数 集合循环函数 @FOR(set_name:constraint_expressions) 对每个元素生成约束 @MAX(set_name:expressions) 表达式的最大值 @MIN(set_name:expressions) 表达式的最小值 @SUM(set_name:expressions) 表达式的和 例：产生序列{1，4，9，16，25} 123456model:sets: number/1..5/:x;endsets @for(number(i):x(i)=i^2);end 例： 12s=@sum(number(i)|i#le# 5: x); !前5个求和m=@min(number(i)|i#ge# 5: x); !5个之后的最小值 输入输出函数 @OLE excel表格读取 @file @text 求解状态 @status() 0 Global Optimum 全局最优 1 Infeasible 不可行 2 Unbounded 无界 3 Undetermined 不确定 4 Feasible 可行 5 Infeasible or Unbounded 6 Local Optimum 局部最优 7 Locally Infeasible 局部不可行（可行解可能存在，但lingo没找到） 8 Cutoff 目标函数的截断值被达到 9 Numeric Error 算数错误 Lingo建模技巧 尽量使用实数优化，减少整数约束和整数变量 尽量使用光滑优化，少用绝对值、符号函数、多变量求最大/最小值、四舍五入、取整等 尽量使用线性模型，x/y&lt;5改为x&lt;5y 合理设置上下界，尽可能给出变量初始值 参数数量级适当，不同参数数量级差距一般要求小于3","link":"/posts/2069852828/"},{"title":"UML学习笔记","text":"当年学习UML时的期末复习笔记，分享一下~ UML Learning Notes UML basic building block thing structural behavior grouping annotation relationship dependency association generalization realization diagram rule name scope visibility integrity完整 execution common mechanism specification adornment common division extensive mechanism扩展机制 stereotype版型 tagged value constraint约束 view of architecture logical implementation process deployment use case Use case diagramActor参与者是系统以外的与系统交互的人或事 物，包括人、设备、外部系统等 Use case用例定义了一组相关的由系统执行的动作序 列，将有价值的可见结果提供给某个参与 者。 Relationship association 泛化（generalization）：抽取一些用例共 同的属性，定义一个基础用例 包含（include）：一个用例的执行要用到 另外的用例 扩展（extend）：把新的用例（功能）插入 到已有用例（基础用例） Methods Establish the context of the system by identifying the actors that surround it. For each actor, consider the behavior that each expects or requires the system to provide. Name these behaviors as use cases. Factor common behavior into new use cases that are used by others; factor variant behavior into new use cases that extend more main line flows. For each use case, describe the typical interactions between the actors and the system. Model these use cases, actors, and their relationships in a use case diagram. Adorn these use cases with notes or constraints that assert nonfunctional requirements. 找出系统外部的参与者和外部系统, 确定系统边界 和范围 确定每一个参与者所期望的系统行为 把这些系统行为命名为用例 使用泛化、包含、扩展等关系处理系统行为的公 共或变更部分 编制每一个用例的脚本 绘制用例图 区分主要事件流和异常事件流, 如果需要, 可以把 异常事件流处理为单独的用例 细化用例图, 解决用例间重复与冲突的问题 Class diagram1234+ public- private# protected~ package aggregation聚合 （空心） Some objects are weakly related like a computer and its peripherals composition组合 （实心） Some objects are strongly related like a tree and its leaves Relationship 泛化 （实线空心三角箭头） 关联 （实线） 聚合 （空心菱形） 组合 （实心菱形） 实现 （虚线空心三角箭头）指向接口 依赖 （虚线箭头） 强弱关系：组合&gt;聚合&gt;关联&gt;依赖 OOD Principles 开闭原则：Open/Closed Principle, OCP 软件实体在扩展性方面应该是开放的，而在更改性方面应该是封闭的 为了满足开闭原则，设计时应尽量使用接口 进行封闭, 采用抽象机制, 并利用OO中的多态 技术 Liskov替换原则：Liskov Substitution Principle, LSP 子类可以替换父类出现在父类能出现的任何地方 依赖倒置原则：Dependency Inversion Principle, DIP 依赖关系应该是尽量依赖接口(或抽象类)，而不是依赖于具体类 抽象不应该依赖于细节, 细节应该依赖于抽象 要针对接口编程, 不要针对实现编程 接口分离原则：Interface Segregation Principle, ISP 使用多个专门的接口比使用单一的总接口要好 Object diagram An object diagram is a snapshot of the objects in a system at a point in time. 对象图表示一组对象和它们之间的关系 对象图是一个系统的详细状态在某时刻的快照 对象图可以看作是类图在某个时刻的实例 对象图的建模元素 对象 对象之间的关系 Package diagram A package is a grouping construct that allows you to take any construct in the UML and group its elements together into higher-level units. A package diagram shows packages and their relationships. Elements: class interface component node use case package… Package -grouping thing 对语义上相关的元素进行分组 提供配置管理单元 在设计时，提供并行工作的单元 提供封装的命名空间，其中所有名称必须唯一 Relationship Supplier&lt;——-Client &lt;&lt; import&gt;&gt; Public elements of the supplier namespace are added as public elements to the client namespace. &lt;&lt; access&gt;&gt; Public elements of the supplier namespace are added as private elements to the client namespace. &lt;> An element in the client uses an element in the supplier in some way. The client depends on the supplier. &lt;&lt; trace&gt;&gt; usually represents an historical development of one element into another more refined version. It is an extra-model relationship. &lt;&gt; The client package merges the public contents of its supplier packages. This is a complex relationship only used for metamodeling - you can ignore it. Nested packages small ⊕—- big Interaction diagram Sequence Diagram 顺序图（序列图） 对象（Object，包括Actor的实例） 生命线（Lifeline） 控制焦点（Focus of control） 消息（Message） Communication Diagram 通信图（协作图） 通信图描述系统中对象之间通过消息进行的交互，强调参加交互的对象的组织结构 通信图有对象链接 通信图必须有消息顺序号 顺序图强调消息的时间顺序，通信图强调参 加交互的对象的组织，两者可以相互转换 Timing Diagram 定时图（时序图） 坐标轴交换了位置，改为从左到右来表示 时间的推移用生命线的“凹下凸起”来表示状态的变化，每个水平位置代表一种不同的状态可显示一个度量时间值的标尺，用刻度表示时间间隔 Interaction Overview Diagram 交互概述图 交互概述图是将活动图和顺序图嫁接在一起的图 它将活动节点进行细化，用一些小的顺序图 来表示活动节点内部的对象控制流 GRASP：“通用职责分配软件模式” Information Expert(信息专家) —把职责分配给信息专家 Creator(创建者)—把接收和处理系统事件消息的职责分配给控制者 Low Coupling(低耦合) —把创建类A实例的职责分配给一个在任何情况下都与被创建对象相关联的创建者 High Cohesion(高内聚) —分配职责时要保持低耦合 Controller(控制器)—分配职责时要保持高内聚 Information Expert 信息专家模式核心思想：把职责分配给具有 完成某项职责所需信息的个体。信息专家模式在职责分配中使用得非常广 泛，它是对象设计中经常使用的基本指导原 则。职责的履行需要信息，而信息往往分布在不 同的对象中。这就意味着许多“部分”的信息专 家有时需要协作才能来完成一个任务。 Problem It Solves: What is a basic principle by which to assign responsibility to objects? Solution: Assign a responsibility to the class that has the information needed to fulfill it. Creator 创建者模式指导怎样分配“与创建对象”相关的职 责。创建者模式的基本目的是找到一个在任何情况 下都与被创建对象相关联的创建者，选择这样的类 作为创建者能支持低耦合。 集合聚集了部分,容器包含了内容,记录器记录了被 记录的数据，这些类之间的关系在类图中非常普 遍。创建者模式建议：封装的容器类和记录器类是 创建“自己包含或者记录的元素”的很好候选者 Problem: Who should be responsible for creating a new instance of some class? Solution: Assign class B the responsibility to create an instance of class A if one or more of the following is true: B aggregates A objects. B contains A objects. B records of A objects. B closely uses A objects. B has the initializing data that will be passed to A when it is created. B is a creator of A objects. Low Coupling 低耦合模式鼓励职责分配时不增加耦合性。 从而避免了高耦合可能产生的不良后果。 优点：不受其它组件改变的影响；便于单独 理解；重用方便 Problem: How to support low dependency, low change impact, and increased reuse? Solution: Assign a responsibility so that coupling remains low. High Cohesion 高内聚模式鼓励职责分配时保持较高的内聚性。 优点：使设计的清晰性和易于理解性得到提高；维护和扩展得到简化；常常支持低耦合；重用性提高。 Controller 控制器是负责接收或者处理系统事件的对象。 把接收或处理系统事件的职责分配给代表整个系统、设备或子系统的类、表示用例场景的类，如&lt; UCName&gt;Handler， Coordinator或Session Problem: Who should be responsible for handling an input system event? Solution: Assign the responsibility for receiving or handling a system event message to a class representing one of the following choices: State machine diagram A state machine models the lifetime of a single object. 状态机图描述对象在整个生命周期的动态行为：它可能经历的状态，什么情况下它离开 一个状态到达另一状态，在这个过程中它做了什么。 想要关注一个对象跨越多个用例的行为 Methods Set the context for the state machine. Establish the initial and final states for the object. Decide on the events to which the object may respond. Starting from the initial state to the final state, lay out the top-level states the object may be in. Connect these states with transitions triggered by the appropriate events. Add actions to these transitions. Identify any entry or exit actions. Expand these states as necessary by using substates. Check all events and actions. Check the state machine against expected sequences of events and their responses. 寻找主要的状态 确定状态之间的转换 细化状态内的活动和转换 用复合状态展开细节 Activity diagram An activity diagram shows the flow from activity to activity. 活动图用来描述事情进行的流程，是UML中 对系统行为建模的一种常用工具活动图描述系统的控制流：从一种活动转换 到另一种活动的整个过程活动图可以对系统的工作流程建模，也可以 对具体的操作建模 Model elements Initial nodes and Final nodes Activity nodes Control flows Decision and Merge nodes Fork and join nodes Partitions and Swim Lanes Object Flows Decision and merge nodes A decision node is a control node that has one input edge and two or more alternate output edges Fork and join nodes Forks nodes model concurrent flows of work Swim lane &amp; Partitions You’ll find it useful, especially when you are modeling workflows of business processes, to partition the activity states on an activity diagram into groups, each group representing the business organization responsible for those activities If you want to show who does what, you can divide an activity diagram into partitions Component diagram Component diagrams show the organization of and dependencies among a set of components Use component diagrams when you are dividing your system into components and want to show their interrelationships through interfaces or the breakdown of components into a lower-level structure. Model elements Component 构件 Interface 接口 Dependency 依赖关系 Components A component is a replaceable part of a system that conforms to and provides the realization of a set of interfaces 构件和类 类描述软件设计的逻辑组织和意图，构件描述软件设计的物理实现构件可以部署，类不能部署 类可以拥有操作和属性，而构件仅拥有可以通过其接口访问的操作 Deployment diagram A deployment diagram models the mapping between the software architecture and the physical system architecture. 部署图描述系统硬件的拓扑结构和软件在硬件上的配置。 Model elements 节点（Node） 连接（Connection） Nodes A node is a physical element that exists at run time and represents a computational resource, generally having at least some memory and, often, processing capability Graphically, a node is rendered as a cube 节点与构件的区别 构件往往表示一个软件部件，节点往往表示 一个硬件部件构件是参与系统执行的事物，节点是执行构件的事物构件表示逻辑元素的物理打包，节点表示构 件的物理部署 UP 统一过程(Unified Process)是一个将用户需 求转化为软件系统所需要完成的一系列任务 的框架，规定了完成各项任务的步骤。 Process model 统一过程是一个二维生命周期模型，纵轴代表 核心工作流，横轴代表时间。一个工作流可 以分配在若干恰当的时间阶段完成；一个阶 段可以涉及多项工作流 Phases 阶段 Inception初启 Life Cycle Objectives - conditions of satisfaction:System scope has been definedKey requirements for the system have been captured. These have been defined and agreed with the stakeholdersAn architectural vision exists. This is just a sketch at this stageA Risk AssessmentA Business CaseProject feasibility is confirmedThe stakeholders agree on the objectives of the project Elaboration细化 Lifecycle Architecture - conditions of satisfaction:A resilient, robust executable architectural baseline has been createdThe Risk Assessment has been updatedA project plan has been created to enable a realistic bid to be formulatedThe business case has been verified against the planThe stakeholders agree to continue Construction构造 Initial Operational Capability - conditions of satisfaction:The product is ready for beta testing in the user environment Transition移交 Product Release - conditions of satisfaction:Beta testing, acceptance testing and defect repair are finishedThe product is released into the user community Characteristics Use case (requirements) driven 用例驱动Architecture centric 构架中心Iterative and incremental 迭代和增量…","link":"/posts/3427290413/"},{"title":"Pandas数据分析常用操作整理","text":"每次用python处理数据，老是记不清函数名😓，总得回去翻以前写的代码，实在太麻烦了，就在这里统一整理了一些pandas的常用操作，方便查阅。【更新中】 读写csv/excel 从csv文件读取 123456frame = pd.read_csv(&quot;./1.csv&quot;)'''encoding=utf8/gbkheader=1''' 从excel文件读取1member_frame=pd.read_excel(&quot;./附件二.xlsx&quot;, sheet_name=&quot;会员信息&quot;) 写入csv文件 1234# numpy array写入文件np.savetxt(&quot;距离.csv&quot;, res_frame, delimiter=&quot;,&quot;,fmt=&quot;%f&quot;)# pandas dataframeroad1_frame.to_csv(&quot;road1.csv&quot;,index=False,sep=',') Dataframe相关操作 排序123frame.sort([&quot;time&quot;, &quot;id&quot;]) # 可多字段排序frame.sort([&quot;time&quot;],ascending=True) # 逆序 按条件筛选行1234567891011121314151617# 单列frame.loc[frame[&quot;grade&quot;] == &quot;B&quot;]# 多列frame.loc[(frame[&quot;grade&quot;] == &quot;B&quot;) | (frame[&quot;loan_amnt&quot;] &gt; 5000)]# 限定显示字段frame.loc[frame[&quot;grade&quot;] == &quot;B&quot;, [&quot;member_id&quot;, &quot;term&quot; , &quot;loan_amnt&quot;, &quot;grade&quot;,&quot;sub_grade&quot;, &quot;int_rate&quot;]]# 多种取值frame.loc[frame[&quot;grade&quot;].isin(['A','B'])]# 取反（加~）frame.loc[~frame[&quot;grade&quot;].isin(['A','B'])]# 包含子串frame.loc[frame[&quot;name&quot;].str.contains(&quot;张&quot;)] dataframe遍历行12for index, task in task_frame.iterrows(): task_frame.loc[index, '任务密度']=task[&quot;num&quot;]/1000 series带index遍历行12for i, v in tmp.iteritems(): # 或 items() print(i, v) 统计某一栏取值分布12road1_frame['hour'].value_counts().sort_index() # 按索引排序frame[&quot;终端号&quot;].value_counts().sort_values(ascending=False) # 按值排序 12345678910111213141516171806 1107 11008 20809 18610 10611 6912 8613 7814 8115 6117 11718 16819 15320 14721 9322 4923 8Name: hour, dtype: int64 unique方法1frame[&quot;终端号&quot;].unique() 12array([&quot;'00064298&quot;, &quot;'00066298&quot;, &quot;'00092298&quot;, ..., &quot;'00156242&quot;, &quot;'00010986&quot;, &quot;'00119246&quot;], dtype=object) 随机抽样12terminal_samples = frame.sample(frac=0.1, replace=False) # 指定比例 无放回terminal_samples = frame.sample(n=100, replace=True) # 指定数量 有放回 新建空Dataframe12hour_distri_frame = pd.DataFrame(columns=[&quot;终端号&quot;] + [x for x in range(24)]) # 设置列名hour_distri_frame = hour_distri_frame.set_index([&quot;终端号&quot;], drop=True) # 设置索引字段 | | 0 | 1 | 2 | 3 | 4 | … | 19 | 20 | 21 | 22 | 23 || ——-: | —-: | —-: | —-: | —-: | —-: | —-: | —-: | —-: | —-: | —-: | —-: || 终端号 | | | | | | | | | | | | 0 rows × 24 columns 时间转换 datetime转timestamp 1frame['time'] = frame['deal_date'].apply(lambda x:time.mktime(x.timetuple())) 转字符串 1frame['date'].apply(lambda x:x.strftime('%Y/%m/%d')) 插入一行 append 12345# 字典形式res = res.append([{'score':10.0}], ignore_index=True)# frame合并insertRow = pd.DataFrame([[0.,0.,0.,0.,0.]],columns = ['date','spring','summer','autumne','winter'])res = res.append(insertRow,ignore_index=True) concat 12newline = pd.DataFrame([{'obj1':obj1,'obj2':obj2,'relation':rel,'count':0, 'desc':desc}]) rel50group_df=pd.concat([rel50group_df,newline],ignore_index = True) 使用index 1df.loc[3]= ['china',123] 删除指定行12df_clear = df.drop(df[df['x']&lt;0.01].index)","link":"/posts/1042606304/"},{"title":"ctex踩坑之路","text":"今天算法老师让我们装个ctex，以后作业要用，我打开了它的首页，Excuse me？ 最新的版本是2012年？我就感觉有些不妙。 看到这行红色小字，说可能会丢失环境变量，我也没多在意，我打开了我的系统环境变量看了眼，也没找到怎么备份（现在知道了?），觉得我脸不会这么黑吧。（事实证明我不该怀疑我的血统。。。） 哎，现在想象就后悔，要不是这个体积比较小，我就去装TexLive了。安装完后问题来了，我怀着忐忑的心情点开环境变量。WTF！！！TM把我系统环境变量删的一个都不剩，你还想运行？简直是欲哭无泪，赶紧上网找有没有恢复的方法。看到网上说电脑没重启的话可以从注册表里找回来。 系统path可能存在的位置HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager\\EnvironmentHKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Control\\Session Manager\\EnvironmentHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment win+R运行，regedit打开注册表，好家伙，我注册表里的环境变量也全被改成这样了。?我只能找同学把他系统的环境变量复制给我。但剩下的python，java，c++，git，mysql，mongodb，redis…环境变量全没了!!!!只能一个个用listary搜安装路径，凭印象加了。估计还有好多只能等以后用到时报错才知道了。 下面附上备份环境变量的方法 先点开编辑系统环境变量 点击编辑文本变量值里就是所有系统path的值(分号分割). 我电脑目前的环境变量(作为备份,以防万一)C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\system32;D:\\ProgramFiles\\CTEX\\UserData\\miktex\\bin;D:\\ProgramFiles\\CTEX\\MiKTeX\\miktex\\bin;D:\\ProgramFiles\\CTEX\\CTeX\\ctex\\bin;D:\\ProgramFiles\\CTEX\\CTeX\\cct\\bin;D:\\ProgramFiles\\CTEX\\CTeX\\ty\\bin;D:\\ProgramFiles\\CTEX\\Ghostscript\\gs9.05\\bin;D:\\ProgramFiles\\CTEX\\GSview\\gsview;D:\\ProgramFiles\\CTEX\\WinEdt;D:\\ProgramFiles\\CUDA\\bin;D:\\ProgramFiles\\CUDA\\libnvvp;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0\\;%SYSTEMROOT%\\System32\\OpenSSH\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Windows\\System32;D:\\ProgramFiles\\Python\\Scripts;D:\\ProgramFiles\\Python;C:\\Program Files (x86)\\Intel\\iCLS Client\\;C:\\Program Files\\Intel\\iCLS Client\\;C:\\Program Files (x86)\\Windows Kits\\8.1\\Windows Performance Toolkit;D:\\ProgramFiles\\Redis-x64-3.2.100;D:\\ProgramFiles\\MongoDB\\Server\\4.0\\bin;D:\\mysql-8.0.16\\bin;D:\\应用程序\\Visual Studio 2015 Enterprise\\VC\\bin;D:\\应用程序\\Visual Studio 2015 Enterprise\\VC\\bin\\x86_amd64;D:\\ProgramFiles\\Anaconda3\\Lib;D:\\ProgramFiles\\Java\\jdk-12.0.2\\bin;D:\\ProgramFiles\\Java\\jdk-12.0.2\\lib;C:\\Program Files\\nodejs;C:\\Program Files\\NVIDIA Corporation\\Nsight Compute 2019.5.0;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;D:\\ProgramFiles\\Git\\bin; 最后问候一下那位程序员的家人， N🐎$L","link":"/posts/198858064/"},{"title":"ctf工具集","text":"nmapnmap是一款开源免费的网络发现和安全审计工具。软件名字Nmap是Network Mapper的简称。Nmap最初是由Fyodor在1997年开始创建的。随后在开源社区众多的志愿者参与下，该工具逐渐成为最为流行安全必备工具之一。 hashcathashcat是自称世界上最快的密码恢复工具。适用于Linux，OS X和Windows的版本可以使用基于CPU或基于GPU的变体。支持hashcat的散列算法有Microsoft LM哈希，MD4，MD5，SHA系列，Unix加密格式，MySQL和Cisco PIX等 WiresharkWireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。 AudacityAudacity是一款非常实用的音频编辑软件，通过该款软件，用户能够非常便捷的进行录音、播放、输入输出WAB、AIFF、Ogg Vorbis和MP3文件等操作，并且还支持大部份常用的工具，如剪裁、贴上、混音、升/降音以及变音特效等。 sqlmapsqlmap是一个自动化的sql注入工具，其主要功能是扫描、发现并利用给定URL的SQL注入漏洞，内置了很多绕过插件，支持的数据库有MySQL, Oracle,PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird,Sybase和SAP MaxDB。 Burp SuiteBurp Suite是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。 HxDHxD - Freeware Hex Editor and Disk Editor，十六进制编辑器 quipqiupquipqiup is a fast and automated cryptogram solver by Edwin Olson. It can solve simple substitution ciphers often found in newspapers, including puzzles like cryptoquips (in which word boundaries are preserved) and patristocrats (inwhi chwor dboun darie saren t). 通过词频分析法，解密替换字母加密文本工具。 TweakPNGTweakPNG是一个互动的PNG文件编辑器实用工具，它允许您查看和修改一些PNG图像文件的元信息存储。这是不是一个真正的图像编辑器或浏览器。TweakPNG包括一个简单的图像浏览器，但它只能被动地显示当前状态的文件。","link":"/posts/2154665753/"},{"title":"python应用打包笔记","text":"简单记录一下python打包工具是使用方法。 pyinstaller基本操作 安装 1pip install pyinstaller 打包 123pyinstaller -F main.py# -W 隐藏cmd窗口# -i ico路径(.ico/.exe) pipenv基本操作 直接用pyinstaller打包可能导致exe文件特别大，动辄几十MB，所以采用虚拟环境构建可以很好的解决这个问题，相比conda，更为轻量，便于跨平台。 创建虚拟环境（将在当前目录下创建虚拟环境，若有requirements文件会自动安装依赖 1pipenv install 此时将会生成Pipfile和Pipfile.lock文件，类似npm的package.json 建议先将Pipfile中的pip源换成清华源 1234[[source]]url = &quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot;verify_ssl = truename = &quot;pypi&quot; 在虚拟环境中安装pyinstaller 12# 把pyinstaller安装到开发环境中pipenv install pyinstaller --dev 进入虚拟环境 1pipenv shell 之后在虚拟环境中使用pyinstaller -F main.py打包，最终程序大小明显减小（40mb-&gt;8mb） 如果要删除虚拟环境，运行pipenv --rm即可。","link":"/posts/1795373516/"},{"title":"matplotlib绘图基本操作&amp;美化教程","text":"这次来整理一波python用matplotlib绘图的常用函数，以及如何修改默认死亡配色。 前期准备导入包123import numpy as npimport pandas as pdimport matplotlib.pyplot as plt 基本设置123456789101112131415plt.figure() # 创建画布plt.rcParams['font.sans-serif'] = ['SimHei'] # 设置字体，不然中文无法显示plt.rcParams['figure.figsize'] = (8.0, 4.0) # 设置figure_size尺寸#figsize(12.5, 4) # 设置 figsizeplt.rcParams['savefig.dpi'] = 300 #保存图片分辨率plt.rcParams['figure.dpi'] = 300 #分辨率# 默认的像素：[6.0,4.0]，分辨率为100，图片尺寸为 600&amp;400# 指定dpi=200，图片尺寸为 1200*800# 指定dpi=300，图片尺寸为 1800*1200plt.rcParams['image.interpolation'] = 'nearest' # 设置 interpolation styleplt.rcParams['image.cmap'] = 'gray' # 设置 颜色 styleplt.savefig('plot1.png', dpi=300) #指定分辨率保存 折线图123456plt.plot(index, value, label='频率')plt.grid(axis=&quot;y&quot;) # 坐标网格plt.legend() # 图例plt.xlabel('迭代次数') # x轴标题 plt.ylabel('亲缘度') # y轴标题plt.xticks(size = 9,rotation = 30) # x轴标签旋转 柱状图123data = [5, 20, 15, 25, 10]plt.bar(data)plt.show() 饼图123456789101112131415161718plt.pie(x, explode=None, labels=None, colors=('b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'), autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center = (0, 0), frame = False )'''x (每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化labels (每一块)饼图外侧显示的说明文字explode (每一块)离开中心距离startangle 起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起shadow 是否阴影labeldistance label绘制位置,相对于半径的比例, 如&lt;1则绘制在饼图内侧autopct 控制饼图内百分比设置,可以使用format字符串或者format function '%1.1f'指小数点前后位数(没有用空格补齐)pctdistance 类似于labeldistance,指定autopct的位置刻度radius 控制饼图半径''' 修改配色默认的配色是真的丑，连我这种直男都看不下去了，虽然可以手动调整每一块的颜色，但这实在太艰难了。 尝试了几种方法，最后还是采用了这篇文章中的方法。 安装brewer2mpl直接pip install brewer2mpl即可。 导入使用这里给个例子： 12345678910111213import brewer2mpl# 参照下方配色方案，第三参数为颜色数量，这个例子的范围是3-12，每种配色方案参数范围不相同bmap = brewer2mpl.get_map('Set3', 'qualitative', 10)colors = bmap.mpl_colorsplt.figure()plt.rcParams['font.sans-serif'] = ['SimHei']# 对于饼图plt.pie(sub_count, labels=[x[0] for x in subjects], colors=colors)# 或者直接修改配色方案plt.rcParams['axes.color_cycle'] = colors 更正：matplotlib1.5版本后配置进行了改动 123456import brewer2mplfrom cycler import cyclerbmap = brewer2mpl.get_map('Set2', 'qualitative',4)colors=cycler('color',bmap.mpl_colors)plt.rcParams['axes.prop_cycle'] = colors 附上配色方案： 来看看效果，比原来的死亡配色好看多了。","link":"/posts/1237182484/"},{"title":"python正则用法整理","text":"叒是一篇笔记整理，这次来整理下python的正则匹配。其实主要就是几个函数的区别。 match(), search(), findall(),finditer()区别 match()仅匹配字符串开头是否正确，如果首字符不匹配就返回None search()寻找第一个匹配的结果，返回一个match对象 findall()查找所有匹配项，返回匹配的子串列表 finditer()跟findall类似，只不过返回的是个迭代器 1234567891011import resrc = &quot;22你好 世界&quot;pat = re.compile('[\\u4e00-\\u9fa5]+')pat.search(src)&gt;&gt; &lt;re.Match object; span=(2, 4), match='你好'&gt;pat.search(src).group() # 返回匹配的内容&gt;&gt; 你好pat.search(src).span() # 返回匹配子串的下标元组&gt;&gt; (2, 4)pat.findall(src) # 返回匹配子串列表&gt;&gt; ['你好', '世界'] 常用正则表达式 匹配邮箱 \\w[-\\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\\.)+[A-Za-z]{2,14} 匹配中文（不含标点） [\\u4e00-\\u9fa5]+ 匹配时间（hh:mm:ss） ([01]?\\d|2[0-3]):[0-5]?\\d:[0-5]?\\d 匹配ip \\d{0,3}\\.\\d{0,3}\\.\\d{0,3}\\.\\d{0,3} 匹配日期（年-月-日） (([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29) 向前匹配和向后匹配 (?&lt;=前).*?(?=后) 最后附上一个超级好用的在线正则测试工具","link":"/posts/2862589559/"},{"title":"python模块相对路径引用错误处理","text":"python的相对地址导入包一直是个让人头疼的事。 比如你想从process.py里导入父文件夹里的setting.py 12345├─ settings.py│ __init__.py│├─analysis │ process.py 不就from .. import settings吗，结果就报了奇怪的错 1234&gt;&gt;&gt; from .. import settingsTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: attempted relative import beyond top-level package 参考了StackOverflow上的高赞回答，其实解决方法也很简单，在import之前加上这两句： 123import syssys.path.append(&quot;..&quot;)import setting # 直接导入父目录下的模块 意思是，把父目录添加到环境变量中，就可以直接import模块了。 不过有时候启动的位置不是当前文件的同级目录，可能还会报错，那就需要再加上这两句设置运行目录为当前文件所在的目录。 12import osos.chdir(os.path.dirname(__file__)) 因此导入模块最万无一失的方法就是： 12345import osimport sysos.chdir(os.path.dirname(__file__)) sys.path.append(&quot;..&quot;)import settings","link":"/posts/3276205951/"},{"title":"【更新日志】FileBrowser网盘","text":"2020-02-01 新增个人网盘基于Filebrowser Filebrowser是一款简洁好用的在线文件管理软件，支持上传、批量下载、多用户管理、在线预览多种格式，在线编辑文本，还能够外链分享，可谓是功能齐全。 而且安装非常简单，开箱即用。下面就来介绍一下如何配置开机自启，并使用nginx实现https访问。 安装1curl -fsSL https://filebrowser.org/get.sh | bash 启动命令 1./filebrowser -p 8080 -a 0.0.0.0 此时就可以通过你的ip:8080访问网盘了，如果有安全组别忘了放行8080端口 默认用户名和密码都是admin 基本配置接下来的配置过程基本都能在网页上进行 修改密码，修改网站名称，修改根目录，有需要可以新增用户。 开机自启以CentOS 7 为例，可以使用systemctl配置开机自启服务。 在/etc/systemd/system目录下新建一个filebrower.service文件，输入以下内容： 12345678910[Unit]Description=File BrowserAfter=network.target[Service]# 必须是绝对路径！ExecStart=/root/server/fileserver/filebrowser -d /root/server/fileserver/filebrowser.db[Install]WantedBy=multi-user.target 配置域名用ip地址的访问方式太不优雅了，","link":"/posts/1139947415/"},{"title":"【更新日志】备案成功","text":"好消息！好消息！从今天起，本站正规上线啦！ 等待了21天，备案终于通过了。除了等待时间有些长，流程还算比较简单，主要需要填写个人基本信息，签署承诺书然后拍一段视频，之后就是漫长的等待。 有了备案，终于能部署到国内服务器了，网站访问体验改善不少。也总算有一个比较稳定的服务器环境了，之前租的vps，频出故障，三天两头要搬迁，本站的很多功能都被迫下线了。现在是时候考虑回归了，当然也希望能整出些新花样。 敬请期待！","link":"/posts/2516373275/"},{"title":"【更新日志】网页沙盒","text":"2020-02-12 新增jsproxy网页沙盒功能 采用jsproxy+cloudflare worker，无须服务器，无须代理，点击即用。 PS. 由于目前无法转发谷歌验证的流量，如果触发验证码了短时间内就没法用了，过一段时间再试试吧~ 🔗链接","link":"/posts/682898760/"},{"title":"交叉编译lrzsz串口传输工具及踩坑过程","text":"嵌入式Linux开发的过程中传输文件是个挺麻烦的事，主要有三种方式： SD卡拷贝（需要反复插拔，mount/umount比较麻烦） TFTP网络传输（速度快，但需要网线） 串口传输（无需额外接口，但速度很慢） 本文主要介绍君正T40平台上使用串口传输文件的方式。 正篇：lrzsz工具编译使用教程编译工具链准备下载所用开发板配套的工具链，如君正T40平台提供的mips-linux-gnu-xxx，并配置好环境变量 下载准备 lrzsz源码 地址：https://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz 在PC上解压 支持串口传输的shell客户端，如SecureCRT（正版需要收费，就不贴链接了，自行百度） 交叉编译 配置编译参数 方便起见，可以在源码根目录新建一个run.sh文件，填入以下内容HOST``BUILD改成你的开发板的架构 123456789101112#!/bin/bash CUR_DIR=`pwd`HOST=mips-linux-gnuBUILD=mips-linux-gnuINSTALL_PREFIX=${CUR_DIR}/lrzsz_outmkdir -p ${INSTALL_PREFIX}LDFLAGS=-muclibc echo &quot;ac_cv_prog_CC=${ac_cv_prog_CC='mips-linux-gnu-gcc'}&quot; &gt;&gt; mips-linux-gnu.cache ./configure --prefix=${INSTALL_PREFIX} --host=${HOST} --build=${BUILD} --cache-file=./mips-linux-gnu.cache 执行sh ./run.sh生成MakeFile文件 执行make &amp;&amp; make install编译 在./lrzsz_out/bin目录下生成了lrz``lrx等6个二进制文件，拷贝至开发板即可运行。 lrz``lrx``lrb分别表示Zmodem, Xmodem, Binary的模式从PC接收文件 lsz``lsx``lsb则表示相应模式的向PC发送文件 一般用lrz和lsz就行 开发板运行 将lrz``lsz二进制文件拷贝到/usr/bin或其他目录 为方便使用，重命名为rz和sz 接收文件输入rz，回车，将自动弹出SecureCRT的传输文件窗口，选择文件-&gt;Add-&gt;OK即可发送 会有进度条，速度大概13KB/s左右吧，聊胜于无，大文件就算了////// 发送文件过程也类似，输入： 1sz filename.jpg 进度条自己开始走，如果用的是Win10，文件会出现在系统的 下载 目录下 正篇结束，看着很简单吧，然而这只是最理想的情况下，我在交叉编译那步开始踩坑，以下请听我细数： 踩坑之路sh: lrz: not found!当我将交叉编译后的二进制拷贝到板子上时，却无法运行！提示信息也有很强的误导性，我一度以为是路径问题。然而，我明明在这，你却not found 百度之后才了解到，not found一般有三种原因： 真的not found：目录下没有这个命令 有，但你不配：执行权限不够 -&gt; chmod 777 即可解决 我人在，但心不在：程序运行需要的静态库或者动态库缺失 我遇到的显然不是第一二种，那看来就是依赖库缺失了。 排查依赖库回到PC上，使用交叉编译工具链中的mips-linux-gnu-readelf分析动态库 果然，需要libnsl.so.1 libc.so.6这两个动态链接库，再回到开发板上确认下: 果然，/lib和/system/lib下都没找到他们的身影。 但没事，从交叉编译工具链那边复制过来不就行了？ 1234find -name &quot;libc.so.6&quot;# ./mips-linux-gnu/libc/lib/libc.so.6find -name &quot;libnsl.so.1&quot;# ./mips-linux-gnu/libc/lib/libnsl.so.1 find一下，也顺利找到了，胜利在望啊！ 赶紧再逝一下！ 依旧 not found！怎么可能！？不会是这2个库还有套娃依赖吧？ 12345678910111213mips-linux-gnu-readelf -d lrzsz_out/bin/libc.so.6Dynamic section at offset 0x1e8 contains 28 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [ld-linux-mipsn8.so.1] 0x0000000e (SONAME) Library soname: [libc.so.6] 0x0000000c (INIT) 0x19268 0x00000019 (INIT_ARRAY) 0x17d55c 0x0000001b (INIT_ARRAYSZ) 4 (bytes) 0x00000004 (HASH) 0x318 0x00000005 (STRTAB) 0xcc7c 0x00000006 (SYMTAB) 0x381c 0x0000000a (STRSZ) 24192 (bytes) 嗯，那继续，把ld-linux-mipsn8.so.1加上总可以了吧。（既然这么说了那肯定没成功 那这个ld-linux-mipsn8.so.1是何方神圣呢？ 原来这是linux动态链接共享库的装载器，也就是一切动态库的根基，他存放的位置就没有那么随便了，必须固定在/lib目录下，可以用mips-linux-gnu-readelf -a命令查证： 可以看到，在程序头部指明了解释器的绝对路径 但不凑巧的是，我的开发板的/lib目录是只读文件系统，无法新增文件 换个链接器Linux的链接装载器不止这一种，那不如换个思路，看看这个板子支持哪个链接器。 欸，ld-uClibc-mipsn8.so.0这个文件名长得很像啊！那能不能加个编译参数，指定用这个链接器呢？ 在君正官方程序的MakeFile中找到了线索： -muclibc这个参数，就是帮助编译器选择使用gclib还是uclib动态库的，对于这个开发板，需要使用的正是uclib版本。 到这里，我以为胜利在望了，结果编译报错了，看来uclib的库并不全，叒有依赖缺失。 12345678make LDFLAG=-muclibcmips-linux-gnu-gcc -DNFGVMIN -DHAVE_CONFIG_H -DLOCALEDIR=\\&quot;/home/zylu/graduate_proj/magik-toolkit/ThirdParty/lrzsz-0.12.20/lrzsz_out/share/locale\\&quot; -I.. -I. -I../src -I../intl -I../lib -muclibc -c lrz.cIn file included from lrz.c:25:0:zglobal.h:188:11: fatal error: libintl.h: No such file or directory # include &lt;libintl.h&gt; ^~~~~~~~~~~compilation terminated. 一路坎坷好不容易到这一步，唯一的希望似乎也被堵死了，但其实离成功不远了。换个思路，既然动态库不行，那能不能把他们打包成一个静态库？ 静态库打包12345make install LDFLAGS=-staticmips-linux-gnu-readelf -d lrzsz_out/bin/lrzThere is no dynamic section in this file. OHHHHHHHHH，终于成功了，可以看到程序已经没有动态链接部分了。上板运行也非常成功，只是二进制文件大一点（从190KB变为900KB，咱不差这点空间！） 总结这原本只是一件小事，没想到牵扯出这么多问题，在解决问题的过程中我也被迫去学习了动态链接库，configure文件功能，MakeFile的参数含义，交叉编译工具使用等等。 Ref： [1] lrzsz的交叉编译与使用 [2] lrzsz小工具的使用 [3] 关于-/bin/sh:xx(命令) not found 的几种原因和解决办法","link":"/posts/2545460615/"},{"title":"人生第一桶金GET！！！","text":"在闲鱼上挂自己近一个月了，终于接到一笔比较大的生意，写一个今日头条的爬虫。我报价1000竟然直接给我砍到650。哎，现在想想还是有点亏啊。不过比起第一单爬微博数据的生意还是好多了。（当时真的是太naive了，我竟然只要了80？！)不过，这毕竟是我人生中第一次接触社会，做生意，有些吃亏也是正常的，至少现在我有些了解行情了，下次报价不会再这么保守了，谈判时也不会这么学生气了。应当要学会握住自己手上的筹码，守住自己的价格底线。现在想想，这是他求我写软件，而不是我想着要赚钱，不过话又说回来，能凭自己的实力花两天时间挣到这笔小钱，也挺有自豪感的。下面就来说说这项任务本身吧。 今日头条，我也是第一次知道它还有网页端，而且还有个高仿微博的“微头条”板块，这也是这次数据采集的对象，也正是因为它跟微博很像，我才会接这笔生意。就 m 端 json 数据格式而言，我觉得还是后起之秀，今日头条写的比较规整，清晰（好爬）。而且值得一提的是，每页返回的json包中都会记录下一页的起始offset，而且这个offset还就是时间戳，这就使按日期搜索成为了可能。相较之下，微博采用page参数，把数据分页逻辑写在了后端，严格控制最多返回的页数，这就给爬取完整数据带来了很大的困难。（可能是微博被爬虫爬到烦了吧，现在的反爬机制越来越严了）既然提到反爬机制，那就提一嘴，今日头条的反爬机制就只是通过referrer是否为本站判定，没有检查cookie或登录情况，而且3秒一爬，长时间内还比较稳定。这当然得夸一下。（当然是从数据采集者角度? 这也是我第一次做一个真正意义上的产品出来，不得不说pyinstaller一键封装真好用。由于gui费时费力，我也懒得做最后只能整个如此原味（丑陋）的命令行界面。为了防止他拿到软件直接跑路，我还贴心地给他加了个时间限制，你说改系统时间就行了？其实我还设置了自动从服务器下载配置，他要爬数据，总得开网络吧。所以，虽然说是“试用版”，但它比“完整版”功能还多一点呢！? 下面附上主要代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255import requestsimport jsonimport osimport reimport timefrom colorama import Fore, Back, Style, init# version 1.2 #def toutiaoSpider(uid, stimestamp, etimestamp): conf_dic = {'uid': uid, 'stimestamp': stimestamp, 'etimestamp': etimestamp} page_count = 0 item_count = 0 offset = int(round(etimestamp * 1000)) while True: response = getFeed(uid, offset) page_count += 1 content_jsons = json.loads(response.content.decode(&quot;utf-8&quot;)) print(Fore.BLUE + '[%d] %s' % (page_count, response.url)) date_str = time.strftime( &quot;%Y-%m-%d %H:%M&quot;, time.localtime(offset / 1000)) print(Fore.LIGHTCYAN_EX + '【当前页面时间】 ' + date_str) # print(offset) for item in content_jsons['data']: item_json = json.loads(item['content']) # 下面解析主要内容 text = item_json.get('content') # ##文本 if text is None: continue create_time = item_json['create_time'] # 时间戳 # 转换成localtime time_local = time.localtime(create_time) # 转换成新的时间格式(2016-05-05 20:28:54) date_str = time.strftime(&quot;%Y-%m-%d %H-%M-%S&quot;, time_local) # ##时间 thread_id_str = item_json['thread_id_str'] username = item_json['user']['screen_name'] # 存入文件 path = './output/%s-%s/%s_%s/' % (uid, username, date_str, thread_id_str[-3:]) if not os.path.exists(path): try: os.makedirs(path) except Exception: path = './output/%s/%s_%s/' % (uid, date_str, thread_id_str[-3:]) os.makedirs(path) else: continue read_count = int(item_json['read_count']) rd_str = '' if read_count &gt;= 10000: rd_str = '%.1f万' % float(read_count / 10000) else: rd_str = str(read_count) with open(path + rd_str + '.txt', 'w', encoding='utf-8') as f: f.write(text) # 图片 img_tags = item_json.get('large_image_list') if img_tags is not None: for img_tag in img_tags: img_url = img_tag.get('url') getImg(img_url, path) item_count += 1 print(Fore.BLUE + Back.LIGHTYELLOW_EX + '第 %d 页完成，共获取 %d 条内容' % (page_count, item_count)) # 任务完成判定 last_off = offset offset = content_jsons['offset'] if last_off != 0: if last_off &lt;= offset or offset &lt;= int(round(stimestamp * 1000)): print(Back.YELLOW + Fore.LIGHTMAGENTA_EX + &quot;\\n【任务完成！】&quot;) os.remove('./config.json') os.system(&quot;pause&quot;) return # 更新配置文件 with open('./config.json', 'w') as f: conf_dic['etimestamp'] = offset / 1000 json.dump(conf_dic, f) time.sleep(3)def getFeed(uid, offset): requests.packages.urllib3.disable_warnings() base_url = 'https://profile.zjurl.cn/api/feed/profile/v1/' param = {'category': 'profile_all', 'visited_uid': uid, 'offset': offset} header = { 'referer': 'https://profile.zjurl.cn/rogue/ugc/profile/?user_id=%s' % uid, 'User-Agent': 'Mozilla/5.0 (Linux; U; Android 8.1.0; zh-CN; BLA-AL00 Build/HUAWEIBLA-AL00) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.108 UCBrowser/11.9.4.974 UWS/2.13.1.48 Mobile Safari/537.36 AliApp(DingTalk/4.5.11) com.alibaba.android.rimet/10487439 Channel/227200 language/zh-CN' } i = 0 while i &lt; 5: try: response = requests.get( base_url, params=param, headers=header, verify=False, timeout=5) if response.content == b'': print('[EMPTY RETRY]') i += 1 time.sleep(5) continue return response except requests.exceptions.RequestException: print('[RETRY]') i += 1 time.sleep(5) return None# 获取图片def getImg(url, path): requests.packages.urllib3.disable_warnings() header = { 'referer': 'https://profile.zjurl.cn/', 'User-Agent': 'Mozilla/5.0 (Linux; U; Android 8.1.0; zh-CN; BLA-AL00 Build/HUAWEIBLA-AL00) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.108 UCBrowser/11.9.4.974 UWS/2.13.1.48 Mobile Safari/537.36 AliApp(DingTalk/4.5.11) com.alibaba.android.rimet/10487439 Channel/227200 language/zh-CN' } i = 0 while i &lt; 5: try: response = requests.get( url, headers=header, verify=False, timeout=5) if response.content == b'': print('[EMPTY RETRY]') i += 1 time.sleep(5) continue # 解析成功 img_id = re.findall( r'(?&lt;=/)([^/]+?)(?=\\?from)', response.url)[0].replace('.image', '.gif') print(Fore.GREEN + '[IMG] ' + Style.RESET_ALL + response.url) img_path = path + '/img/' if not os.path.exists(img_path): os.makedirs(img_path) with open(img_path + img_id, 'wb') as f: f.write(response.content) return except requests.exceptions.RequestException: print('[RETRY]') i += 1 time.sleep(5) return Nonedef main_process(): print(Fore.CYAN + Style.BRIGHT + &quot; ________________ \\n&quot; + &quot; | 欢迎使用 |_____ __ \\n&quot; + &quot; | 微头条采集器 | |__| |_________ \\n&quot; + &quot; |________________| |::| | / \\n&quot; + &quot; /\\**/\\ | \\.____|::|__| &lt; \\n&quot; + &quot; ( o_o )_ | \\::/ \\._______\\ \\n&quot; + &quot; (u--u \\_) | \\n&quot; + &quot; (||___ )==\\ \\n&quot; + ' ,dP&quot;/b /= ( / P&quot;/b\\ \\n' + &quot; |8 || 8\\=== || 8 \\n&quot; + &quot; `b, ,P `b, ,P \\n&quot; + ' &quot;&quot;&quot;` &quot;&quot;&quot;` \\n' + ' \\n') continue_flag = '' if os.path.exists('./config.json'): try: with open(&quot;./config.json&quot;, 'r') as load_f: load_conf = json.load(load_f) uid = load_conf['uid'] stimestamp = load_conf['stimestamp'] etimestamp = load_conf['etimestamp'] sdate_str = time.strftime( &quot;%Y-%m-%d %H:%M&quot;, time.localtime(stimestamp)) edate_str = time.strftime( &quot;%Y-%m-%d %H:%M&quot;, time.localtime(etimestamp)) if stimestamp == 0: sdate_str = '开始时间未设置' if etimestamp == 0: edate_str = '结束时间未设置' print(Fore.YELLOW + Style.BRIGHT + '检测到配置文件!') print(Fore.YELLOW + Style.BRIGHT + 'ID: %s\\n%s~%s' % (uid, sdate_str, edate_str)) continue_flag = input('是否继续上次任务？(y/n)') except Exception: pass if continue_flag == 'y': toutiaoSpider(uid, stimestamp, etimestamp) return while True: uid = input('请输入需要采集的博主id,如(6767668116)：') print(Fore.LIGHTMAGENTA_EX + '您输入的是：' + uid) stimestamp = 0 etimestamp = 0 sdate_str = '' edate_str = '' # 开始时间 while True: try: stime_str = input('请输入开始时间（yyyy mm dd HH MM）:') if stime_str != '': t = time.strptime(stime_str, '%Y %m %d %H %M') stimestamp = int(time.mktime(t)) sdate_str = time.strftime( &quot;%Y-%m-%d %H:%M&quot;, time.localtime(stimestamp)) print(Fore.LIGHTMAGENTA_EX + '您输入的是：' + sdate_str) else: stimestamp = 0 sdate_str = '开始时间未设置' print(Fore.LIGHTMAGENTA_EX + sdate_str) break except Exception: print(Fore.RED + '输入格式错误，请重新输入') # 结束时间 while True: try: etime_str = input('请输入结束时间（yyyy mm dd HH MM）:') if etime_str != '': t = time.strptime(etime_str, '%Y %m %d %H %M') etimestamp = time.mktime(t) edate_str = time.strftime( &quot;%Y-%m-%d %H:%M&quot;, time.localtime(etimestamp)) print(Fore.LIGHTMAGENTA_EX + '您输入的是：' + edate_str) else: etimestamp = 0 edate_str = '结束时间未设置' print(Fore.LIGHTMAGENTA_EX + edate_str) break except Exception: print(Fore.RED + '输入格式错误，请重新输入') print(Fore.LIGHTMAGENTA_EX + '\\n您的输入是：\\n ID：%s \\n %s ~ %s' % (uid, sdate_str, edate_str)) verify = input('确定？(y/n)') if verify == 'n': continue else: break # ######### 输入结束 ########### # 生成配置文件 conf_dic = {'uid': uid, 'stimestamp': stimestamp, 'etimestamp': etimestamp} with open('./config.json', 'w') as f: json.dump(conf_dic, f) toutiaoSpider(uid, stimestamp, etimestamp)if __name__ == &quot;__main__&quot;: init(autoreset=True) main_process()","link":"/posts/703409997/"},{"title":"今天你体温上报了吗？","text":"沉寂一个学期后，终于有空折腾点东西了。不知不觉每天起床第一件事——健康打卡已经快一年了。下至-274℃上至9999999999999℃，都无人过问，有时忘了打卡还要被不停的催。身为程序猿怎么能忍受此般形式主义每天霸占我宝贵的1分钟！（所以我花了两天时间写了这个程序) 下面步入整体，本来我觉得这不就抓个包每天定时发送就行了吗。然而事情并没有想象中那么简单，这个登录状态每天都会失效，所以不能存个cookie就完事。一番研究下，学校的登录认证系统还有点东西。应该是采用客户端cookie+服务端session的方式。 参考了小猴偷米的认证代码，得知网页认证过程如下： 登录页面包含动态生成的密钥等隐藏表单信息，客户端将账号、使用动态密钥加密和的密码再次POST至登录页地址； IDS 服务器解析表单参数，判断用户成功登陆，并生成 Ticket 作为参数，请求前端 302 跳到新信息门户； 前端再次 GET 请求带 Ticket 参数的新信息门户链接； 新信息门户取 Ticket 参数，私下与 IDS 服务器进行验证，验证成功后向前端颁发统一身份认证 Cookie。 知道了原理后就好办了，依葫芦画瓢把js写的代码翻译成python就行。唯一碰到的难点就是加密算法的实现。原项目中的js代码都是经过混淆的，通过人眼辨认实在太麻烦，我又尝试几种现成的AES加密模式什么CBC，OFB等等，发现输出结果都不太像，看来这其中另有玄机。 既然翻译代码不成，那么万能的python能不能直接运行js代码呢？一查还真有！js2py模块简直是我的救星！ 几行代码轻松执行js程序： 1234567891011import js2pycontext = js2py.EvalJs()with open(&quot;./ids-encrypt.js&quot;) as f: js_content = f.read()def encryptAES(data, salt): # 执行整段JS代码 context.execute(js_content) result = context.encryptAES(data, salt) return result 获取到登录session后，自然是我说了算了，校内接口轻松访问。 目前主要实现了 体温上报 和 GPA计算 的功能。 具体功能介绍请见GitHub仓库 下面贴几张运行结果图： 每日上报（部署服务器定时任务后简直美滋滋~） GPA计算 2021.11.23 fork数破百留念 2021.12.26 200 fork达成！ 想不到只过了1个月，fork数和star数刚好翻倍了，想不到我的第一个热门项目竟是他。。。看来果然偷懒才是第一生产力。 2021.3.13 fork 破300，看得出疫情又反复了，希望能再次早日清零吧。","link":"/posts/1769612424/"},{"title":"从申请服务器到建站","text":"1.申请服务器具体过程我就不细说了，新手可以申请一个阿里云可以免费用一个月，够你耍了。（本站的话目前是搭建在Digital Ocean上，以后会做详细的介绍，本文就暂且以阿里云为例） 2.选择环境我选的是centos7，比较稳定，程序包也比较丰富。接下来一番操作，设置密码什么的，系统就基本装好了。 3.配置系统要配置系统的话，就先要进入系统，推荐用ssh连接。windows下的powershell现在已经自带了ssh指令，如果没有的话自行安装一下。用以下命令连接1ssh root@xx.xx.xx.xxxx为你服务器的ip地址接下来会让你输密码，注意这时候光标是不会动的，输完按回车就行。如果你不想每次都输密码，可以用你的ssh工具生成一个公钥传到服务器上在本地运行ssh-keygen一路回车就行，然后你会看到一个奇怪的字符图案就是生成成功了再将公钥传到服务器上 1ssh-copy-id root@10.170.125.14 这样就能免密登录了对于新手玩家，建议用linux面板来管理系统，这样能省很多事，推荐一款宝塔面板，操作起来很方便。Centos安装命令：1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install\\_6.0.sh &amp;&amp; sh install.shUbuntu/Deepin安装命令：1wget -O install.sh http://download.bt.cn/install/install-ubuntu\\_6.0.sh &amp;&amp; sudo bash install.shDebian安装命令：1wget -O install.sh http://download.bt.cn/install/install-ubuntu\\_6.0.sh &amp;&amp; bash install.shFedora安装命令:1wget -O install.sh http://download.bt.cn/install/install\\_6.0.sh &amp;&amp; bash install.sh 基本只有一路回车就行了。记住上面这个画面，按上面的地址就能登录了。进入面板后可以更改密码和登录端口看到图形化界面了，是不是感觉很亲切呢。 3.配置网站这步操作同样很简单，只要点击左边的网站它就会提示你安装推荐选择LNMP架构。然后静静等待就行了。 4.添加站点点击添加站点，输入你的域名，没有的话就输你的ip地址网站的根目录默认为/www/wwwroot/你的域名接下来你就可以把网页丢进去了。在安全中开放80端口如果是阿里云还需要到安全组中开放80端口的入方向重启一下服务或者重启一下服务器，输入你的域名，看，你的网站是不是显示出来了呢。 5.ftp服务器搭建只有网站怎么够呢，顺便再搞个ftp从面板上开通后可能会连不上再从左边软件商店中找到PureFtp这一项点击设置-&gt;配置修改大概在188行ForcePassiveIp 这一行 后面改成你的服务器ip（记得把前面的#去掉）当然也别忘了把21端口打开。","link":"/posts/220013359/"},{"title":"企业应用开发环境","text":"开发工具 idea工具 创建项目（Spring Boot） 构建工具 maven JDK：1.8 Spring Boot\\Druid\\MySQL\\MyBatis Plus 应用接口测试 浏览器 postman 服务接口编码规模 接口参数校验 异常处理，自定义异常封装异常信息 异常信息封装为json对象 约定：errcode(2001:xxxx, 0), data, errmsg 接口服务说明文档 接口服务说明文档 请求方式：GET/POST(HTTP/HTTPS) 接口功能说明：功能描述 请求地址：/user/getuserlist 请求参数说明： 表格 编号 参数名 是否必须 参数说明 返回结果 包含所有可能结果 结果参数说明 表格 编号 字段名 字段说明 企业应用打包 Spring Boot，maven 打包前clean 执行package jar 企业应用jar包运行 上传服务器 服务器有Java运行环境 执行jar包 1234567891011121314nohup java -jar letao-0.0.1-SNAPSHOT.jar &amp;tail -f nohup.outWarn: Could not find @TableId in Class: cn.com.chinahitech.letao.user.entity.User.Parsed mapper file: 'URL [jar:file:/home/hadoop/letao/letao-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/mapper/user/UserMapper.xml]'_ _ |_ _ _|_. ___ _ | _ | | |\\/|_)(_| | |_\\ |_)||_|_\\ / | 3.3.0 17:30:40.964 [main] INFO o.s.s.c.ThreadPoolTaskExecutor -Initializing ExecutorService 'applicationTaskExecutor'17:30:41.683 [main] INFO o.a.coyote.http11.Http11NioProtocol -Starting ProtocolHandler [&quot;http-nio-8081&quot;]17:30:41.834 [main] INFO o.s.b.w.e.tomcat.TomcatWebServer -Tomcat started on port(s): 8081 (http) with context path ''17:30:41.874 [main] INFO c.c.c.letao.LetaoApplication -Started LetaoApplication in 8.79 seconds (JVM running for 10.111) Git服务器提交内容 Java/Python程序源代码 文档（readme.md）/ 作业 / excel 不要提交：class/jar/….","link":"/posts/1674708745/"},{"title":"同步vs异步vs阻塞vs非阻塞","text":"“同步”和“阻塞”的概念，只从字面上理解，很容易让人混淆。我之前也被这两组概念困扰了很久，趁着最近工作不太忙来捋一捋。 概念分析同步与异步同步和异步是针对进行某一操作被调用者的响应方式来说的。 同步操作时，调用者需要等待被调用者执行完毕并返回结果。比如你打电话给书店老板让他找一本书，你等着他找到后告诉你结果。 而异步操作，调用发出后就直接返回了，所以没有直接获得返回结果。被调用者执行完毕后，发出通知告知调用者。这次书店老板直接说“等我找到了，再打电话告诉你”，然后就挂了电话。 阻塞与非阻塞阻塞和非阻塞关注的是调用者在等待被调方返回结果时的动作。 如果是阻塞调用，在收到返回结果前，调用方会被挂起等待，直到收到结果才能进行下一步。就好比你一直听着电话等书店老板告诉你结果，这段时间你不能去做别的事。 而非阻塞调用，在收到结果前，你可以去干别的事。还是上面的例子，你在老板告诉你结果前完全可以去干点别的事，当然也可以隔几分钟去问下老板有没有结果。 总结这两组概念容易造成混淆，主要是因为都是“一个要等待，一个不用等待”。这样理解没用问题，但需要明确他们区别的关键在于动作的主体：同步异步关注的是被调方的处理逻辑，告知结果的时机；阻塞非阻塞关注的是调用者等待返回结果期间的状态。 Linux系统IO模型了解了以上概念顺便再来学习一下Linux系统的IO模型。 前言一次IO操作（以read为例），需要经历2个步骤： 等待数据准备 将数据从内核拷贝到用户进程中 相应的，Linux系统有以下五种IO模式。 阻塞 I/O（blocking IO） 非阻塞 I/O（nonblocking IO） I/O 多路复用（ IO multiplexing） 信号驱动 I/O（ signal driven IO） 异步 I/O（asynchronous IO） 1、阻塞IO在Linux系统中，所有的socket默认都是blocking，当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。这个过程需要等待数据被拷贝到操作系统内核的缓冲区中。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 blocking IO的特点是在IO执行的两个阶段都被block了 2、非阻塞IO当用户进程发出recvfrom调用时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个recvfrom操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是error时，它就知道数据还没有准备好，于是它可以再次调用recvfrom。一旦kernel准备好了数据，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。 3、IO多路复用所谓的I/O复用，就是多个I/O可以复用一个进程。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 select：O(n) 用户进程每次传给内核一个用户空间分配的fd_set表示“关心的 socket”。其结构（相当于 bitset）限制了只能保存 1024 个 socket。每次 socket 状态变化，内核利用fd_set查询 O(1)，就能知道用户进程是否关心这个 socket。内核是复用了fd_set作为出参，返还给用户进程。而用户进程必须遍历一遍 socket 数组 O(n)，才知道哪些 socket 就绪了。 poll：O(n) poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的 epoll：O(1) epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。 select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但多路复用的优势在于它可以同时处理多个connection。 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 附：示例代码 select epoll 4、异步IO用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它收到到一个异步read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 参考资料Linux IO模式及 select、poll、epoll详解 同步、异步和阻塞、非阻塞的区别","link":"/posts/3997962891/"},{"title":"基于Java Swing 的日历桌面应用","text":"这是我大二上学期费时一个月完成的Java大作业。不得不吐槽都9102年了，还有人用Swing写界面？丑到爆不说，页面布局永远是玄学，你永远不知道调了这个参数它是什么效果，区区一个垂直布局，竟只能用一个一个盒子套起来（禁止套娃）。这也太蠢了8。哎，算了不吐槽了，下面进入正题。虽然做的算不上美观，总算能看一下了。功能我自认为实现得比较完善了吧。 Java-CalendarThis is a desktop Calendar application written by Java. 这是用Java Swing写的一个日历应用，可以添加日程提醒，支持本地、服务器双向同步。 使用方法 :warning:由于服务端采用sqlite存储，须提前在./sqlite目录下新建todolist.db数据库文件。 双击runServer.cmd编译并启动服务器 双击runClient.cmd编译并启动客户端主程序（服务器未连接也可本地运行） 主界面 添加日程 数据库服务器 附上Github仓库地址https://github.com/luzy99/Java-Calendar感兴趣的朋友可以fork，star一下哈~ ヾ(≧▽≦*)o","link":"/posts/2446380894/"},{"title":"将你的网站解析到1.0.0.1，Cloudflare羊毛薅到底","text":"Cloudflare这个域名解析服务商相信很多人一定不陌生，它好像是目前唯一免费提供CDN服务的商家，但由于其cdn服务器多数在国外，在国内的访问速度不佳，甚至起不到加速效果，反而会减速。但通过cdn访问，能是你的服务器匿名性提升不少，也能有效避免DDOS攻击，还能减少服务器流量开支，何乐而不为呢？ 那么有没有办法更换DNS服务器地址呢？官网上也确实提供了更改CNAME地址的服务，不过是要收费的。作为一个白嫖党怎么可能付钱呢这两天，我有发现了Cloudflare推出了免费的公共DNS1.1.1.1和1.0.0.1（可真是财大气粗啊，这ip比Google的8.8.8.8还nb）。 那么下面进入正题，我们有没有办法把域名解析到这个网站上呢？以下就是我的操作步骤： Step 1当然得先注册Cloudflare账户，点击Sign up按钮，可以使用邮箱注册，注册完后会让你填写你的二级域名，如本站就是luzy.tk，可能会让你在原域名商那里验证一下，记不太清了，反正跟着步骤走就行。显示这样的界面就是注册好了。 Step 2点击上图中的你的站点，选择上面DNS菜单，点击ADD RECORD 新增域名解析记录，Name表示域名，只需要填写第三级域名（如下图中blog即表示blog.luzy.tk），Content中填写你的服务器ip。记得再把右边的云朵点亮（灰色表示只使用DNS，橙色表示开启CDN）。 Step 3此时，若把下方的nameservers地址填入你的原始域名服务商上的nameserver地址，就完成了Cloudflare的默认cdn配置。此时你可以用你的电脑ping一下你的网站域名，会发现它的ip地址变了，不是你原来的地址了。但这不是我们想达到的效果，如果想使其解析到1.0.0.1还需下面的步骤。 Step 4这里要登录你的原始域名服务商（就是你申请域名的那个网站），我们要把nameserver恢复成默认，（也就是移除Step 3 的修改），在DNS管理界面填上你的域名，与之前Cloudflare上填的类似，不过要注意的是，ip地址那栏，不要填你的真实ip！ 不要填你的真实ip！ 不要填你的真实ip！ 一律填上1.0.0.1！（1.1.1.1被国内各厂商定义为内网网关ip了，用不了，1.0.0.1还是亲测可用的）至此，就大功告成了！等个十分钟左右，等修改生效，再用你的电脑ping一下。看，是不是解析成1.0.0.1了呢。? 原理猜测：默认cdn的解析路径：根据你的顶级和二级域名找到其归属的服务商—&gt;服务商根据你设置的域名服务器地址，把请求传给Cloudflare—&gt;Cloudflare返回分配的cdn地址修改后的解析路径：根据你的顶级和二级域名找到其归属的服务商—&gt;服务商直接把你的域名解析成1.0.0.1返回 我们能够如此利用，估计是Cloudflare设置了这两个ip也能作为cdn使用，至于怎么返回真实网站内容的，我也不清楚了。（以上纯属本人个人理解和猜测，如有理解错误请大佬指出附上对blog.luzy.tk的路由追踪的结果：可以看到，追踪到1.0.0.1就断了，可以说，这招使服务器的安全性提高不少","link":"/posts/2416903650/"},{"title":"基于Scrapy的关键词式新闻爬虫","text":"这是我闲鱼上接的第二个单子，既然做完了，那就干脆把项目开源吧。其实主要就是把之前写过的百度搜索爬虫改成了谷歌，又添加了几个新闻站点的解析。 GitHub项目地址 心得体会先来说一下心得体会，接这个单主要还是因为之前做过新闻爬虫，改起来也比较简单，这也是难得的不是爬微博的单子（真被微博搞怕了。。。），半年来愿者上钩一个单子也确实不容易。 这单子其实也不是那么省心，爬虫倒是早就写完了，把样例数据图表都给他看了也不鸟我，到最后，他自己论文来不及写了，急了，又跟我说做的图不符合他的要求。行啊，我也熬夜帮他改了，又说图表配色不好看，网站爬错了（我寻思你也没给我发过网址啊！我给你截图你也没说有问题）。我也算好说话了，数据都给你，你自己去画个统计图总行了吧，最后逼逼赖赖还是被砍了100。。。就当提前见识下无理甲方了呗。 但毕竟我这目的也不是为了赚钱，完成这项工作的过程中还是学到不少的。比如知道了谷歌搜索不管你首页显示搜到了多少条结果，其实最多只会显示1000条（百度只有750条），实际情况更少。而且谷歌的反爬机制还是挺强的，基本上爬了几百条结果就会触发验证码了，好在谷歌的镜像站比较多，可以换着用，被封的概率就小了很多了。 附 谷歌镜像站： gogoo.ml gug1.icu 此外，对于jieba库和matplotlib库的使用也是更熟练了。学习上的收获还是挺大的。 项目介绍 基于Scrapy框架 谷歌高级搜索（爬取新闻链接） 关键词、站点自定义 新闻页面解析（已包含人民日报、纽约时报、东方新闻、星岛新闻页面解析） MySQL存储 数据分析（词云、词频等） 可拓展目录结构 主体为Scrapy工程目录结构 utils目录下包括繁简转换插件，原项目地址 analysis目录下为一些简单的数据分析代码，包括分词、词频统计等。 spiders下包括谷歌搜索、人民日报、纽约时报、东方新闻、星岛新闻爬虫 如何使用 修改settings.py中关于数据库的配置项 12345MYSQL_HOST = '127.0.0.1' # 数据库地址MYSQL_DBNAME = 'job_news' # 数据库名称MYSQL_USER = 'root' # 数据库账号MYSQL_PASSWD = '123456' # 数据库密码MYSQL_PORT = 3306 启动谷歌搜索爬虫 1scrapy crawl google -a kw=关键词 -a site=站点网址 启动新闻站点爬虫 1scrapy crawl 爬虫名 demo展示 新闻目录 新闻内容 词云 词频 开发说明 新增新闻站点爬虫 在项目根目录执行： 1scrapy genspider example example.com 仿照peopleNews.py修改即可。","link":"/posts/3051215520/"},{"title":"巫师三通关纪念","text":"断断续续玩了近一年，137小时终于通关了巫师三主线+2个DLC，支线也通了70%左右（不过估计三分之一的时间都沉迷于打昆特牌🤣）。这也成了我steam库存里游玩时间最长的一款游戏。 结局选了椰奶，女儿当上了女皇，比较满意的一个结局。 唯一比较遗憾的是陶森特打了个姐妹双亡的结局。 下面来谈一谈通关感受。 50块钱能买到100+小时的主线，还有几十小时的支线，以及数不清的问号（反正我肯定是清不完了）。简直超值！买不了吃亏买不了上当！ 但成也剧情败也剧情。剧情过于冗长，前期推进较慢，打了几小时还没出新手存，升级巨慢，赚钱超难（游戏里个个都是奸商），也成了劝退许多新手玩家的主要原因。（我也差点被劝退了。。。） 一但你静下心来品味剧情，抱着一种看电影的心态去欣赏这款游戏，就能被这人和怪物共生的世界观所吸引。猎魔人的职责并不只是打怪杀怪，许多任务往往有同时不伤害怪物的更好选择。是一味的杀戮还是耐心的探寻真相，这一切都基于你的选择。正如游戏中的“五德”（荣誉、慷慨、智慧、怜悯、英勇），这才是骑士所应包含的品质，也是猎魔人所应有的品质。 再来谈一谈游戏的美术风格，从阴暗压抑的威伦，到繁荣热闹的诺城，再到暴风巨浪的史凯利格，最后再到温馨祥和的陶森特。油画般的风格跟中世纪神话配合的恰到好处。 我印象最为深刻的就是血与酒DLC中的童话世界，可谓都是作者魔改的暗黑版童话，卖火柴的小女孩卖起了毒品；狼外婆受够了重蹈覆辙的故事情节，把小红帽丢进了井里；“狼来了”的孩子永远说着反话；长发公主等不及王子到来上吊自杀了……这些毁童年的剧情加在这样一步作品中却别有一番风味。 总的来说，这是目前我最喜欢的一款3A大作，丰富的主线剧情、广阔的探索空间、多分支剧情、诸多彩蛋玩法、优秀的画面和背景音乐，无疑是一段绝佳的试听盛宴。","link":"/posts/2892033077/"},{"title":"微博API汇总及 mid和url的转换算法","text":"微博API 汇总1. 搜索 m端 [GET] https://m.weibo.cn/api/container/getIndex?containerid=100103type%3D1%26q%3D关键词&amp;page_type=searchall&amp;page=2 weibo.cn（简版） [POST]高级搜索（须登录） http://weibo.cn/search/mblog? keyword=关键词 &amp;advancedfilter=1（高级搜索） &amp;starttime=20200201（开始日期） &amp;endtime=20200210（结束日期） &amp;sort=time或hot（实时or热门） &amp;page=1 2.评论 m端 [GET] https://m.weibo.cn/api/comments/show? id=4469270321071880（微博id(mid)） &amp;page=3 weibo.cn（简版）旧版网站采用的是url方式，并未采用mid [GET] https://weibo.cn/comment/IthYFj4xx (url, 可用mid转换计算得) ?page=2 附：mid-url转换函数 微博采用的是base62编码来进行mid映射 base62即 26个小写字母+26个大写字母+10个数字=62 可用python进行实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091ALPHABET = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; def base62_encode(num, alphabet=ALPHABET): &quot;&quot;&quot;Encode a number in Base X `num`: The number to encode `alphabet`: The alphabet to use for encoding &quot;&quot;&quot; if (num == 0): return alphabet[0] arr = [] base = len(alphabet) while num: rem = num % base num = num // base arr.append(alphabet[rem]) arr.reverse() return ''.join(arr) def base62_decode(string, alphabet=ALPHABET): &quot;&quot;&quot;Decode a Base X encoded string into the number Arguments: - `string`: The encoded string - `alphabet`: The alphabet to use for encoding &quot;&quot;&quot; base = len(alphabet) strlen = len(string) num = 0 idx = 0 for char in string: power = (strlen - (idx + 1)) num += alphabet.index(char) * (base ** power) idx += 1 return numdef mid_to_url(midint): # &gt;&gt;&gt; mid_to_url(3501756485200075) # 'z0JH2lOMb' # &gt;&gt;&gt; mid_to_url(3501703397689247) # 'z0Ijpwgk7' # &gt;&gt;&gt; mid_to_url(3501701648871479) # 'z0IgABdSn' # &gt;&gt;&gt; mid_to_url(3500330408906190) # 'z08AUBmUe' # &gt;&gt;&gt; mid_to_url(3500247231472384) # 'z06qL6b28' midint = str(midint)[::-1] size = len(midint) / 7 if len(midint) % 7 == 0 else len(midint) / 7 + 1 result = [] for i in range(int(size)): s = midint[i * 7: (i + 1) * 7][::-1] s = base62_encode(int(s)) s_len = len(s) if i &lt; size - 1 and len(s) &lt; 4: s = '0' * (4 - s_len) + s result.append(s) result.reverse() return ''.join(result)def url_to_mid(url): # &gt;&gt; url_to_mid('z0JH2lOMb') # 3501756485200075L # &gt;&gt; url_to_mid('z0Ijpwgk7') # 3501703397689247L # &gt;&gt; url_to_mid('z0IgABdSn') # 3501701648871479L # &gt;&gt; url_to_mid('z08AUBmUe') # 3500330408906190L # &gt;&gt; url_to_mid('z06qL6b28') # 3500247231472384L url = str(url)[::-1] size = len(url) / 4 if len(url) % 4 == 0 else len(url) / 4 + 1 result = [] for i in range(int(size)): s = url[i * 4: (i + 1) * 4][::-1] s = str(base62_decode(str(s))) s_len = len(s) if i &lt; size - 1 and s_len &lt; 7: s = (7 - s_len) * '0' + s result.append(s) result.reverse() return int(''.join(result))","link":"/posts/794074733/"},{"title":"机器学习模型常见漏洞","text":"数据投毒——伪造点击强加关联，污染推荐算法；投入噪声图像（图案、光照） 模型后门——大量输入图像上有无关特征“点” 模型窃取——大量调用已部署的模型，拟合出近似模型","link":"/posts/2848047303/"},{"title":"搭建hadoop分布式环境","text":"安装环境 CentOS 8 JDK：1.8_231 hadoop：3.2.1 主机准备 主机名：hadoop vi /etc/hostname 主机名与IP地址映射： 12vi /etc/hostsIP地址 hadoop 防火墙关闭 1systemctl status firewalld 创建hadoop用户 12useradd hadooppasswd hadoop hadoop用户环境变量，配置JDK； /home/hadoop/.bash_profile 安装Hadoop 配置hadoop用户免密登录(ssh) ```bashcd ~ssh-keygen -t rsacd .sshcat id_rsa.pub &gt;&gt; authorized_keyschmod 600 authorized_keyschmod 700 ~/.ssh/1234562. 验证免密 ```bash ssh hadoop exit 上传文件 解压，移动到/usr/下 1234tar zxvf hadoop-3.2.1.tar.gzsumv /home/hadoop/tools/hadoop-3.2.1 /usr/su - hadoop hadoop环境变量 ~/.bash_profile 1234567891011$ vi ~/.bash_profileJAVA_HOME=/usr/jdk1.8.0_231HADOOP_HOME=/usr/hadoop-3.2.1PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$JAVA_HOME/bin:$PATHexport JAVA_HOMEexport HADOOP_HOMEexport PATH$ source .bash_profile hadoop的基本配置文件，hadoop-env.sh 12345$ cd /usr/hadoop-3.2.1/etc/hadoop$ vi hadoop-env.sh54 export JAVA_HOME=/usr/jdk1.8.0_231 测试基本配置是否完成 1234567hadoop versionHadoop 3.2.1Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r b3cbbb467e22ea829b3808f4b7b01d07e0bf3842Compiled by rohithsharmaks on 2019-09-10T15:56ZCompiled with protoc 2.5.0From source with checksum 776eaf9eee9c0ffc370bcbc1888737This command was run using /usr/hadoop-3.2.1/share/hadoop/common/hadoop-common-3.2.1.jar 准备目录 /usr/local/hadoop，用于job执行临时目录，和数据存储 12cd /usr/local/chown hadoop:hadoop hadoop 核心配置 core-site.xml $HADOOP_HOME/etc/hadoop/core-site.xml 12$ vi /usr/hadoop-3.2.1/etc/hadoop/core-site.xml fs.defaultFS hdfs://hadoop:9000 hadoop.tmp.dir /usr/local/hadoop/tmp 12345678910111213141516171819202122232425262. hdfs-site.xml `$HADOOP_HOME/etc/hadoop` ```xml &lt;!-- 文件存储在hdfs上的副本数量--&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;!-- hdfs web监听端口--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;hadoop:9870&lt;/value&gt; &lt;/property&gt; &lt;!-- namenode数据存储路径 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;!-- datanode数据存储路径 --&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/dfs/data&lt;/value&gt; &lt;/property&gt; mapred-site.xml 1234567891011&lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt; /usr/hadoop-3.2.1/etc/hadoop:/usr/hadoop-3.2.1/share/hadoop/common/lib/*:/usr/hadoop-3.2.1/share/hadoop/common/*:/usr/hadoop-3.2.1/share/hadoop/hdfs:/usr/hadoop-3.2.1/share/hadoop/hdfs/lib/*:/usr/hadoop-3.2.1/share/hadoop/hdfs/*:/usr/hadoop-3.2.1/share/hadoop/mapreduce/lib/*:/usr/hadoop-3.2.1/share/hadoop/mapreduce/*:/usr/hadoop-3.2.1/share/hadoop/yarn:/usr/hadoop-3.2.1/share/hadoop/yarn/lib/*:/usr/hadoop-3.2.1/share/hadoop/yarn/* &lt;/value&gt;&lt;/property&gt; yarn-site.xml 1234567891011121314&lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hadoop&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt; /usr/hadoop-3.2.1/etc/hadoop:/usr/hadoop-3.2.1/share/hadoop/common/lib/*:/usr/hadoop-3.2.1/share/hadoop/common/*:/usr/hadoop-3.2.1/share/hadoop/hdfs:/usr/hadoop-3.2.1/share/hadoop/hdfs/lib/*:/usr/hadoop-3.2.1/share/hadoop/hdfs/*:/usr/hadoop-3.2.1/share/hadoop/mapreduce/lib/*:/usr/hadoop-3.2.1/share/hadoop/mapreduce/*:/usr/hadoop-3.2.1/share/hadoop/yarn:/usr/hadoop-3.2.1/share/hadoop/yarn/lib/*:/usr/hadoop-3.2.1/share/hadoop/yarn/* &lt;/value&gt;&lt;/property&gt; workers 1hadoop 启动Hadoop集群 首次启动hadoop，必须namenode格式化，命令如下： 123$ hdfs namenode -format2020-07-07 14:25:59,234 INFO common.Storage: Storage directory /usr/local/hadoop/dfs/name has been successfully formatted. 启动两个服务（HDFS、yarn），命令如下： 12345678910111213$ start-dfs.sh$ start-yarn.sh$ jps14337 Jps11608 jar13610 SecondaryNameNode13867 ResourceManager13388 DataNode13261 NameNode13997 NodeManager HDFS管理命令 hdfs安全模式查看 12345$ hdfs dfsadmin -safemode getSafe mode is OFF# 注意：Safe mode is OFF，说明HDFS安全模式已经关闭，实现对数据的读写操作 查看根目录结构 1$ hdfs dfs -ls / 创建目录 123$ hdfs dfs -mkdir /data$ hdfs dfs -ls / 递归创建目录 123$ hdfs dfs -mkdir -p /data/subdata/input$ hdfs dfs -ls -R / 上传本地文件到htfs目录 123$ hdfs dfs -put jdk-8u231-linux-x64.tar.gz /data/$ hdfs dfs -ls /data 下载hdfs数据文件到本地操作系统 123$ hdfs dfs -get /data/jdk-8u231-linux-x64.tar.gz ./$ ll 复制文件 1$ hdfs dfs -cp /data/jdk-8u231-linux-x64.tar.gz /data/subdata/jdk.tar.gz 删除文件 1$ hdfs dfs -rm -r /data/subdata/ HDFS管理命令 安全模式 123$ hdfs dfsadmin -safemode get# hdfs dfsadmin -safemode get|enter|leave|wait report命令 1$ hdfs dfsadmin -report 12345678910111213141516171819202122232425262728293031323334353637383940Configured Capacity: 37558423552 (34.98 GB)Present Capacity: 29635686400 (27.60 GB)DFS Remaining: 29440000000 (27.42 GB)DFS Used: 195686400 (186.62 MB)DFS Used%: 0.66%Replicated Blocks: Under replicated blocks: 0 Blocks with corrupt replicas: 0 Missing blocks: 0 Missing blocks (with replication factor 1): 0 Low redundancy blocks with highest priority to recover: 0 Pending deletion blocks: 0Erasure Coded Block Groups: Low redundancy block groups: 0 Block groups with corrupt internal blocks: 0 Missing block groups: 0 Low redundancy blocks with highest priority to recover: 0 Pending deletion blocks: 0-------------------------------------------------Live datanodes (1):Name: 192.168.1.103:9866 (hadoop)Hostname: hadoopDecommission Status : NormalConfigured Capacity: 37558423552 (34.98 GB)DFS Used: 195686400 (186.62 MB)Non DFS Used: 7922737152 (7.38 GB)DFS Remaining: 29440000000 (27.42 GB)DFS Used%: 0.52%DFS Remaining%: 78.38%Configured Cache Capacity: 0 (0 B)Cache Used: 0 (0 B)Cache Remaining: 0 (0 B)Cache Used%: 100.00%Cache Remaining%: 0.00%Xceivers: 1Last contact: Tue Jul 07 14:54:09 CST 2020Last Block Report: Tue Jul 07 14:28:45 CST 2020Num of Blocks: 2 HDFS回收站 默认关闭 启动回收站 core-site.xml 1","link":"/posts/3506883051/"},{"title":"【更新日志】doccano在线文本标记","text":"2020-02-16 新增doccano在线文本标记功能项目来自Github大佬🔗 2020-07-04 目前功能已下线","link":"/posts/401661891/"},{"title":"武汉加油！中国加油！","text":"这个春节对全中国人来说都是难忘的。这绝对称得上史上最冷清的一个春节。 03年的时候我还小，对SARS没有什么特别的印象，只从父母长辈的话语中了解到当时的情况是多么危急。我也是最近才去查了下非典的来龙去脉，5个多月的时间里，八千多人被感染，七百多人死亡，这个数字在当时13亿人口的庞大基数下显得微不足道，得病概率还比不上一次车祸，但一场瘟疫带来的影响远非多少人失去生命那么简单，它带来的是民间的巨大恐慌，经济上的重创，国家应急能力的考验。 谁曾想到，短短17年，灾难再次卷土重来，灾祸的源头竟大概率还是野生动物贩卖，17年来人们就没有吸取一点教训？这也是我第一次离灾难靠的这么近，从封城到封省，连我们这里远离疫区的城市都开始封锁道路，愈发体会到事态的严重。疫病的传播速度原比所有人想象的都快，短短一个月的时间确诊和死亡人数竟已超过了当年非典。?令人恐惧。 下面再来谈一谈我在家禁闭了十天的感受。用一个字总结，就是“闲”，每天睡到9、10点钟，醒来第一件事，刷刷微博，看一下最新的疫情信息，首先看到总确诊人数一夜见竟涨了一千多，心里一惊，迅速往下翻看本省市情况，看到本市才新增一两例，才放心继续躺着响应国家号召赖一会儿床。白天也没别的事，敲代码，打游戏，偶遇一个晴天，跟父母全副武装去公园透透气，公园里的人比起往日貌似也没有少多少（大家都在家憋得慌了吧），只是人人都戴上了口罩?。（见到不戴口罩的都绕着走） 这可能是我人生中最长的寒假了，也是第一次盼望着早点开学的寒假。此刻，2020年02月02日20时20分20秒在这特殊的时刻，我由衷祈盼病魔散去，生活回归正常。? 武汉加油！中国加油！ 附上这张堪比电影海报的同人图 第一次在博客里记录生活，写得比较琐碎，请见谅（虽然也没人看到吧）。会想到写这篇随笔也是因为我太无聊了吧。?","link":"/posts/3698089233/"},{"title":"七擒七纵之腾讯面经","text":"这次面试可以用恐怖来形容，比阿里、字节都难多了。更离谱的是面试过程中竟然串台了，同时接到2个面试官电话，同一个号码。真不知道腾讯是怎么安排的，真假面试官，我也不知道我这面的有没有问题。 总之这次面试就非常难，非常离谱。 1. 腾讯云后台开发岗面试开始还是先自我介绍，因为项目中提到了影响力排名，就被问到了影响力排名算法，然后引申出如何找出k条最大的记录，我答了用优先队列和排序。 然后问了: 数据库处理大规模查询操作的优化方法 高并发下的自增主键造成数据库负载过大的问题 c++的纯虚函数 冒泡排序（这我竟然一时愣住了） TCP头里有哪些内容（这我哪记得住） TTL是干啥的（避免回环） Linux命令（tail, ls, grep, touch） Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 3.10 更新 上次面试第二天一查，流程已终结，我还厚着脸皮去群里问了下昨晚那情况会不会有影响，hr回应说都是一个部门的结果没影响，这回是坐实挂了。。。 3.16 更新 前两天又收到了游戏客户端开发岗的面试通知，想不到这么快就被捞起来了。这次一定要好好准备。 2. 北极光工作室游戏客户端开发岗今天接到面试电话，才知道是北极光工作室（好像都没啥名气），主要是移动端开发，base上海。 这面试官也没让我自我介绍，上来就说看我成绩还不错，今后是不是考虑读研，我说挺想直接工作的，如果能进这样的大厂就不读研了。他反问我像你这样成绩不错的不都会去读研吗？（看来上来他就没抱希望招我） 然后就开始问我项目了，差不多让我逐一介绍了差不多每个项目（课程设计项目也没放过），问了团队有几个人，你担任了什么工作。有几个项目是C++写的，他就顺势问了下C++的了解程度，问了下智能指针，基类中的析构函数为什么一般定义为虚函数。 然后问了对游戏开发有什么了解，我如实回答了只是玩过。。。又问了对图形渲染，游戏引擎有什么了解，我说了下用过WebGL，讲了一下流水线绘制过程。 面试就差不多到此为止了，我问了下部门的主要工作，主要是移动端开发，还有unity引擎的魔改，主要用到C#和C++。 至此就结束了，连QA环节都只有20分钟，专业课知识一点都没问，白费我那么多时间准备了。 感觉这部门也挺卑微的，这回总不会这门快就给我踢了吧？ An hour later… 一刷新网页，好家伙，又凉了。 你部门既然不要我，捞我出来作甚？（腾讯好感度-10086） 3.19 更新 这回又是广州的微信部门来电话了。。。不会吧，不会吧，不会真有人连挂三次吧。 3. 微信小游戏后台开发这回是视频面试，有手撕代码环节，但没问项目。 这次简直太难了，果然腾讯很注重基础，问了很多底层细节。 map的底层实现（红黑树） C++还有什么数据类型（我答unordered_map） 哈希表如何实现，表大小如何设置，是否需要扩容。（扩容我不会了） 会扩容，增加桶的数量，rehash 手撕代码：LRU实现 幸亏考前刚好看过，知道是用哈希表和双向链表实现，但面试官特别注重细节，指出了我get()操作后没有移动位置，指针没有初始化，没写析构函数等等。。。 static作用（我忘了还能修饰函数） 12345678910// 1.hstatic int a;//1.cpp#include&quot;1.h&quot;// 2.cpp 中能否访问//2.cpp#include&quot;1.h&quot;//2.cpp 中能否访问 include的过程我竟然都说错了（应该是把头文件中的内容替换过来） C++传参机制，比如printf(&quot;%d,%d,%d&quot;,1,2,3)如何知道有几个参数，数据类型是什么（我只记得编译原理里好像说过是用栈传的，具体原理就不知道了） C/C++函数参数的传递方式有三种：值传递（pass by value）、指针传递（pass by pointer）、引用传递（pass by reference）。 C/C++函数参数的传递通道是通过堆栈传递，默认遵循__cdecl(C声明方式)，参数由调用者从右往左逐个压入堆栈，在函数调用完成之后再由调用者恢复堆栈。 指针传递和引用传递在机制是一样的，都是将指针值(即地址)压入栈中，调用函数，然后恢复栈。 值传递会形成一个拷贝。如果是一个自定义的结构类型，并且有很多参数，那么如果用值传递，这个结构体将被分割为非常多个32Bit的逐个拷贝到栈中去，这样的参数传递效率是非常慢的。所以结构体等自定义类型，都使用引用传递，如果不希望别人修改结构体变量，可以加上const修饰，如(const MY_STRUCT&amp; _value); udp/tcp 区别，udp能否实现可靠传输，udp包大小 1、添加seq/ack机制，确保数据发送到对端 2、添加发送和接收缓冲区，主要是用户超时重传。 3、添加超时重传机制。 送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 4.PCG运营开发3.25 辣鸡tx真的越来越离谱了，今天这上来都不自报家门了，要不是我主动问他都不知道我面了个啥。真是槽点太多。。。 先记下有用的： 给两个字符串，计算日期差（我用的python，datetime一减就行） 列举10个Linux命令 C++析构函数有什么用 貌似就没了。。。。 当他问了“你比较熟悉Java吧”，我回了否就知道大概又没戏了。 视频面他也没开摄像头，声音听起来像是没睡醒，那边一直有电话声音，说有人找他。 他问我对前端了解多少，我打出个问号，我这面的不是后端吗？？？ 又问我了解大数据吗？我说不了解，那真的无了。。。 你同学怎么评价你，用3个词形容一下，兴趣是什么？？？？这是HR面吗？实在没的问了吗？ 最后也没留提问环节，还是我主动问的才知道他是PCG大数据部门。。。 总结：体验极差，希望不要有下次了！！！只发邮件不打电话，一律是冲KPI！ 5.微信支付4.8 时隔一周多终于又有部门捞我了，这次又是只给我发了邮件，没打电话，根据前几次的经验，我还是犹豫了一下要不要接受，最后点了时间不合适，在留言框里表明了我的态度，冲KPI的，免谈！果然，晚上打电话来了，表明了他的诚意，就接受了。 今天下午2点通过腾讯会议面的，写代码用的腾讯文档，面试流程比较短总共40分钟，2题代码，15分钟，说是2选一，我写了一道半。 123456789/*1. 如何利用下面的随机源生成0-10000之间的随机数？unsigned char rnd();//返回[0,255]闭区间的随机数*/int rnd10000(){int res;while(res=rnd()*256+rnd() &gt; 60000);return res % 6;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*2. 嵌套数组的遍历，实现hasNext和next函数。注意： a) 一个NestedVector实例中的数据只可能是int数组或NestedVector数组 b) 根据isNested判断属于哪种类型 c) 可以在class内外增加变量或函数 d) 遍历时空数组需要跳过class NestedVector{public://Havebool isNested();const vector&lt;int&gt;&amp; getElement();//可能为空const vector&lt;NestedVector&gt;&amp; getNest();//可能为空//TODObool hasNext();//是否还有下一个元素int next();//返回当前的元素，然后移动到下一个元素private:vector&lt;int&gt; intList;vector&lt; NestedVector&gt; nvList;};void main(){NestedVector nv;…//向nv写入数据while(nv.hasNext()) cout &lt;&lt; nv.next();}以下例子均需输出1 2 3 4：● [1,2,3,4]● [[1,2],[3,4]]● [[],[1,2,3,4]] 不存在[1,2,[3,4]]这种情况*/// 类似 力扣 341. 扁平化嵌套列表迭代器 https://leetcode-cn.com/problems/flatten-nested-list-iterator// ANS: 我没写完就大致说了下思路class NestedVector{public://Havebool isNested();const vector&lt;int&gt;&amp; getElement();//可能为空const vector&lt;NestedVector&gt;&amp; getNest();//可能为空//TODOstack&lt; pair&lt;vector&lt;NestedVector&gt;::iterator, vector&lt;NestedVector&gt;::iterator&gt; stk;NestedVector(){if(isNested()){stk.emplace( nvList.begin(), nvList.end());}}bool hasNext()/是否还有下一个元素{while(!stk.empty()){auto p=stk.top();if(p.first==p.second){ //末尾stk.pop();continue;}if(p.first-&gt;isNested()==false){if(p.first-&gt;intList.size()&gt;0)return true;else return false;}else{}}}int next();//返回当前的元素，然后移动到下一个元素private:vector&lt;int&gt; intList;vector&lt; NestedVector&gt; nvList;};void main(){NestedVector nv;…//向nv写入数据while(nv.hasNext()) cout &lt;&lt; nv.next();} 最后我斗胆问了下能过吗，面试官说我答得不错，但决定不在他手上。 没过多久又收到了初试通知，不知道是挂了又被捞了还是进了第二轮。祈祷放我过一次吧！！！ 6.微信支付 二面4.12 问了下面试官，还是微信部门，应该是二面了吧。 今天的面试流程比较常规，提问+做题。只是我自我介绍还没讲完就被打断提问了。 提问内容： 对HTTP协议的理解 访问一个url的过程 TLS连接过程 map和hash_map区别 数据库查询优化 主键索引和唯一索引区别 数据库隔离级别，解决方法 红黑树插入最多移动几个节点（两次） h&lt;=2log(n+1) （1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 hash表解决冲突方法 开放地址法 线性探测再散列 二次探测再散列 伪随机探测再散列 再哈希法 链地址法 建立公共溢出区 c++程序执行main函数前的过程 设置栈指针 初始化static静态和global全局变量，即data段的内容 将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容 运行全局构造器，估计是C++中构造函数之类的吧 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数 线程进程区别 协程是什么 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 不需要多线程的锁机制 线程间通信方法 匿名管道通信：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 高级管道通信：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。 有名管道通信： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列通信：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号量通信：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存通信：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字通信( socket ) ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 手撕代码：数字转人民币大写 7.微信支付 三面4.14 上来就一道编程题，合并列表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//两个有序（从小到大）单链表，合并为一个有序的单链表struct LinkNode { int value; struct LinkNode * next; LinkNode(int v=0){value=v;next=nullptr;}};struct LinkNode * merge( struct LinkNode * firstLink, struct LinkNode * secondLink ){ LinkNode* head=new LinkNode(); head-&gt;next=nullptr; LinkNode* p1=firstLink; LinkNode* p2=secondLink; LinkNode* newhead=head; while(p1!=nullptr&amp;&amp;p2!=nullptr){ if(p1-&gt;value &gt; p2-&gt;value){ head-&gt;next=p1; p1=p1-&gt;next; }else{ head-&gt;next=p2; p2=p2-&gt;next; } if(head-&gt;next==nullptr || head-&gt;value!=head-&gt;next-&gt;value){ head=head-&gt;next; head-&gt;next=nullptr; } } if(p1==nullptr)head-&gt;next=p2; else head-&gt;next=p1; LinkNode* res=newhead-&gt;next; delete newhead; return res;}#include &lt;iostream&gt;using namespace std;void printLink(LinkNode* p){ cout&lt;&lt;&quot;[&quot;; while(p!=nullptr){ cout&lt;&lt;p-&gt;value&lt;&lt;&quot; &quot;; p=p-&gt;next; } cout&lt;&lt;&quot;]\\n&quot;;}int main() { LinkNode* p1=new LinkNode(); LinkNode* p2=new LinkNode(); LinkNode* h1=p1; LinkNode* h2=p2; for(int i=10000;i&gt;0;i-=2){ h1-&gt;next= new LinkNode(i); h1=h1-&gt;next; h1-&gt;next= new LinkNode(i); h1=h1-&gt;next; } for(int i=10;i&gt;0;i-=1){ h2-&gt;next=new LinkNode(i-1); h2=h2-&gt;next; } printLink(p1-&gt;next); printLink(p2-&gt;next); LinkNode* p3=merge(p1-&gt;next,p2-&gt;next); printLink(p3);} 主键和唯一索引区别 order by 线程间通信 4.26 今天终于OC了，躺了躺了 4.27 收到offer邮件，已接受","link":"/posts/3274961897/"},{"title":"百度搜索API","text":"最近需要做一个爬取新闻网站的项目，但考虑到各个网站的搜索api都不同，且准确性较低，所以我想到了百度的高级搜索功能，于是就对其搜索api探索了一番。 以下就是我整理的百度api参数列表，可能不够全面，欢迎补充. 百度搜索API基本链接1http://www.baidu.com/s?wd=关键字&amp;cl=类型&amp;pn=页码&amp;ie=gb2312&amp;rn=显示条数&amp;tn=原站点 基本链接2https://www.baidu.com/s?q1=主关键词&amp;q2=&amp;q3=&amp;q4=&amp;gpc=stf&amp;ft=&amp;q5=&amp;q6=news.sina.com.cn cl: 类型，3网页，2图片 pn: 页码 ie: 编码 rn: 显示条数 q1: 包含以下全部的关键词 q2: 包含以下的完整关键词 q3: 包含以下任意一个关键词 q4: 不包括以下关键词 q5: 查询关键词位于 : 0(默认)任意位置，1 标题中，2 URL中 q6: 限定站点 gpc和ft应该是限定时间和文档格式 tn：表示源站点，基本没什么用，但我发现了一个神奇的参数baidurt，貌似是简版页面(爬虫首选！！)","link":"/posts/471744165/"},{"title":"网络数据采集与存储","text":"网络访问工具 访问工具：浏览器 测试工具：postman 编程实现：apache httpclient 响应返回的也买你数据解析 jsoup实时页面数据解析 document对象数据抽取 抓包工具：Charles :warning:注意 多线程 无间断 实现功能 httpclient发送请求访问豆瓣电影Top250 html, jsoup, 字符串 抽取页面数据 logback 本地存储的数据同步到HDFS实现步骤 创建project工程(maven) pom.xml, httpclient, jsoup, logback 分析访问页面请求的规律 https://movie.douban.com/top250 https://movie.douban.com/top250?start=25&amp;filter= https://movie.douban.com/top250?start=50&amp;filter= 响应数据的规律 li标记对 电影名称、评分、评价人数","link":"/posts/4113488456/"},{"title":"记一次服务器迁移","text":"用了一年的DigitalOcean终于到期了，服务器配置还是不错的，只是这网速真的是一言难尽，才用了没多久，后台面板都没办法直连了，服务器出故障了强制重启还只能另寻他路登录后台。。。不过这5刀一年近乎白嫖还要啥自行车？ 在服务器到期前赶紧物色下一台小鸡，看了不少评测网站，最终选择了一款极具性价比的极光VPS，优惠后1H1G30Mbps一年只要200块！美西CN2线路和香港CMI线路都挺不错的，带宽也够大，用了1个多月来香港线路还是比较稳定的，平均延时只有50ms左右，太香了！虽说国内小厂有跑路风险，但自用挂个博客站在偶尔挂点测试站足够了，配置下自动备份到谷歌云，也不怕他跑路了。 好像扯远了，下面来讲一讲迁移过程中踩到的坑吧。 站点迁移宝塔面板有非常方便的网站迁移功能，按官网教程配置好api密钥就能一键迁移了，需要注意的是，需要保证两台机子的web环境（nginx、php、mysql）完全一致，我一开始迁移失败就是因为Mysql版本不同。 必要工具安装一台新的机子肯定要重新配置运行环境，这也是非常头疼的一件事。这部分内容我在另一篇文章里整理了，方便以后重装系统时不用再到处去找教程了。 👉Linux 主机初始化环境配置 博客站迁移之前我的个人博客站用的是WordPress，这确实是一款成熟优秀的博客站点框架，自带用户系统和评论系统，也有丰富的插件可以使用。但它是基于php编写的，同时需要mysql支持，而这两个又是服务器占内存的大户。而最为致命的是内容迁移起来是真的头疼。如果只是整站迁移倒还好，配置好域名，数据库、网站目录直接搬走就行。但如果想把文章导出归档就特别麻烦，由于WordPress是把文本内容存数据库里，而图片资源是按照时间分文件夹整理的，把文章一篇篇整理导出需要花不小的功夫。 所以趁还没写几篇文章，赶紧导出整理成markdown，转用对markdown十分友好的Hexo了。 选好主题后美观度完全不输WordPress！用Typora配合sm.ms图床写博客真的太舒服了！文章搬运起来也非常方便，完全不用管图片外链转换了！ 附相关文档链接: 👉主题商店 👉Valine评论插件 👉Hexo官方文档 后记: 其实7月初就完成迁移了，万恶的实训害我鸽到现在。现在博客主题只是随便找了一个，还没找到最合适的。之后可能会出一篇自定义主题的教程。","link":"/posts/85944428/"},{"title":"虚拟机环境配置","text":"课程内容 Linux操作系统（VirtualBox、CentOS） MySQL数据库 Spring Boot开发环境 Ajax编程（Vue/Axios） 企业应用部署(Nginx/jar/负载) hadoop分布式环境 hdfs常用命令/管理命令 Java应用访问hdfs数据 HttpClient工具应用 jsoup页面解析 logback日志存储 flume日志采集工具 Hive数据仓库 Sqoop数据迁移工具 软件工具 git Anaconda3 Azkaban-3.84.0 VirtaulBox IntelliJIDEA FileZilla FinalShell SecureCRT CentOS8 hadoop-3.2.1 hive-3.1.2 Flume MySQL-8.0.19 Nginx-1.16.1 Sqoop2 CentOS 8 安装 root hadoop CentOS 8 配置 关闭防火墙 1systemctl stop firewalld 禁用防火墙 1systemctl disable firewalld 查看状态 123456systemctl status firewalld# 如下显示已禁用● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) 禁用SELINUX 12vi /etc/selinux/config# line7: SELINUX=disabled vi 命令： i 输入 :wq 保存+退出 或 ZZ :q! 强制退出 常用命令 关机：shutdown -h now root(超级管理员)，家目录/root hadoop(普通用户)，家目录/home/usr 切换目录：su - hadoop 在root用户下修改主机名 1vi /etc/hostname CentOS安装JDK 使用hadoop用户上传 jdk-8u231-linux-x64.tar.gz 解压 1tar zxvf jdk-8u231-linux-x64.tar.gz 使用root用户移动目录到/usr下 1mv /home/hadoop/tools/jdk1.8.0_231 /usr 配置环境变量 123456789101112su - hadoopcd ~vi .bash_profile# User specific environment and startup programs JAVA_HOME=/usr/jdk1.8.0_231 PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export PATH:wqsource .bash_profilejavac -version","link":"/posts/1230520748/"},{"title":"记录一次服务器中挖矿病毒","text":"今天打开宝塔面板突然注意到cpu占用100%，顿时感觉不正常，赶紧top看了下后台进程。 果然有个叫xmrig的进程占用cpu100%。网上一查，果然，这是个门罗币挖矿工具，想不到我这小破服务器也会中招。好在这机器上没什么重要文件，就当是借此机会学习下病毒程序是如何攻破服务器的，升级下服务器的安全防护措施吧。 排查过程溯源病毒程序首先赶紧把病毒程序停了 1killall xmrig 可惜进程杀掉后立刻就重启了，看来只能先找到源文件了。 12find / -name '*xmrig*'# /root/c3pool/xmrig 这病毒文件藏得不深，很快就找到了。看了下目录结构，是挖矿脚本没错了。赶紧把二进制文件删掉，再杀进程，算是临时解决了。 排查系统日志但这个程序是怎么启动起来的呢？还有没有别的后台程序呢？那就从系统日志入手，看看病毒启动时有没有留下什么端倪。 1234less /var/log/syslog# 注意先ls一下按日期确认下是哪个syslog切片# 搜索下可能的关键词/c3pool 发现从14号开始，就有个cron定时任务会启动这个挖矿脚本，应该就是差不多这时候中招的吧。 先不去检查cron配置，我们再看下系统登录日志，是否是ssh被攻破了呢。 1less /var/log/auth.log 果然出现了异常登录记录，而且还顺带发现了一个异常systemd服务。赶紧把它disable并删除了。 检查crontab配置回到crontab的问题上，需要注意的是crontab的配置文件在3个地方都有，一定要仔细排查，我一开始就漏了。用crontab -l只会显示下面第一个位置的配置！ cat /var/spool/cron/crontabs/* cat /etc/cron.d/* cat /etc/crontab 最终在/etc/crontab中发现了异常注入。 总结虽然找出了挖矿脚本的启动流程，但整个线索到注入crontab就断了，翻遍了日志也没找到ssh被攻破的证据。攻击者是用何种手段篡改的crontab也不得而知了。","link":"/posts/477432945/"},{"title":"记字节跳动校招一面","text":"字节跳动的校招系统做的还是不错的，可以选择2个部门（但以第一志愿为主），上午报完名，下午就来电话约一面时间了。 面试用的牛客的面试平台，网页端视频面试，面试总体感受是面试官比较随意，上来就说过完年好久没面过了，都不知道怎么面。。。 面试主要流程还是： 自我介绍 项目经历 &amp; 专业知识考察 编码考察 候选人Q&amp;A 附 字节跳动-数据平台官方面试手册 这次主要还是针对项目问了挺多，比如LDA，TF-IDF。然后最迷惑的是编码能力测试时，竟然让我随便写个算法或数据结构，我一时也想不出，只能又写了遍二分。 迷惑操作2，又从我的博客上copy了一道力扣题，让我做，我也只能凭借残留的记忆涂了一下。（我竟然自己给自己出难题！） 然后是我的一个大失误，我竟然说了我对sql比较熟，也使用过HIVE，结果就给我出了到难题，看似简单，却把我难住了，只能屈服向面试官请教答案。 emt表 字段： uid（用户id） salary(薪资) emid(部门id) 查找出每个部门工资最高的2位 emid uid salary A 1 100 A 2 99 B 4 200 B 5 100 答案 &gt; select tmp.emid,tmp.uid,tmp.salary from (select emid,uid,salary, row_number() over(partition by emid order by salary desc ) as rn from emt )tmp where rn&lt;=2 到此为止，可以说这次面试基本凉了，就当吸取教训吧。 没有十足的把握，千万不要说熟悉！！！ 没有十足的把握，千万不要说熟悉！！！ 没有十足的把握，千万不要说熟悉！！！","link":"/posts/2658303721/"},{"title":"记阿里校招实习一面","text":"前两天导员发了几个阿里内推链接，我就联系了流量监控部门的学长，投了简历。学长很热情，耐心指导了我面试的要点，简历投了2天后今天早上接到了晚上电面的通知。赶紧复习了一天专业知识和算法。 面试流程面试流程分为：自我介绍、提问环节、项目经历介绍、手撕代码、闲聊。 晚上7点，电话准时打过来（电话标记广告推销？？？）。说了下流程，直入主题，跳过了自我介绍的环节。 提问环节 差不多把专业课问了个遍，怪我没有好好复习，专业课知识全还给老师了，答的是稀烂 计网：TCP拥塞控制 上来第一个问题就把我问懵了，我只隐约记得个滑动窗口，三次握手，全程答非所问。 参考资料 TCP协议有两个比较重要的控制算法，一个是流量控制，另一个就是阻塞控制。 TCP协议通过滑动窗口来进行流量控制，它是控制发送方的发送速度从而使接受者来得及接收并处理。而拥塞控制是作用于网络，它是防止过多的包被发送到网络中，避免出现网络负载过大，网络拥塞的情况。 拥塞控制四个算法为慢启动，拥塞避免，拥塞发生和快速恢复。 慢启动 初始化拥塞窗口cwnd大小为1 一个往返延迟时间RTT过后，cwnd翻倍（指数增长） cwnd超过 ssthresh（阈值）时，进入“拥塞避免“ 拥塞避免 每经过RTT就把cwnd加一 拥塞发生 若发生拥塞，ssthresh设为cwnd/2 快重传 发送方收到三个重复确认，立即重传（不用等重传计时器到期） 快恢复（与快重传配合使用） 采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。（考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。） 操作系统：fork()，exec()区别 这题还好依稀记得fork是复制一份，exec是加载了新程序覆盖了原来的进程 参考资料 对于fork（）：1、子进程复制父进程的所有进程内存到其内存地址空间中。父、子进程的 “数据段”，“堆栈段”和“代码段”完全相同。2、子进程的当前工作目录、umask掩码值和父进程相同，fork（）之前父进程打开的文件描述符，在子进程中同样打开，并且都指向相同的文件表项。3、子进程拥有自己的进程ID。 对于exec（）：1、进程调用exec（）后，将在同一块进程内存里用一个新程序来代替调用 exec（）的那个进程，新程序代替当前进程映像，当前进程的“数据段”， “堆栈段”和“代码段”背新程序改写。2、新程序会保持调用exec（）进程的ID不变。 操作系统：内核态、用户态概念 内核态与用户态是操作系统的两种运行级别，操作系统为不同操作指令定义了不同特权级，特权指令比如IO只能在内核态下运行。 操作系统：应用程序使用系统调用有哪些优化空间 这问题没太理解，后来他补充说明把一段内存写入磁盘，瓶颈在哪我就答了磁盘IO，优化就说了用cache。。。 数据库查询优化，如何提高查询效率 有哪几种排序算法，复杂度怎样，挑一种算法讲解一下（我讲了快排） | 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性（相同元素的相对位置） || ———————— | ————————— | ————————— | ————————— | ——————— | ———————————————— || 冒泡排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 || 直接选择排序 | O(n²) | O(n²) | O(n) | O(1) | 不稳定 || 直接插入排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 || 快速排序 | O(nlogn) | O(n²) | O(nlogn) | O(nlogn) | 不稳定 || 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 || 希尔排序 | O(nlogn) | O(ns) | O(n) | O(1) | 不稳定 || 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 || 计数排序 | O(n+k) | O(n+k) | O(n+k) | O(n+k) | 稳定 || 基数排序 | O(NM) | O(NM) | O(N*M) | O(M) | 稳定 | 讲一下队列和栈和他们的使用场景 除了先进先出和先进后出我也讲不出别的了/(ㄒoㄒ)/~~ c++的static的用途和使用场景 这个应用场景我也就讲了个实例计数。真的想不出来了。。。 项目经历介绍这个环节主要挑了些你写在简历上的项目问你实现细节，问的还是挺细的。总之好好准备就行。 手撕代码他会给你发邮件，链接点进去是个在线编辑器，当场出题，直接写代码，不能运行调试。 还好他只问了一个简单的二分查找。今天还刚看到了。 闲聊时间最后就是闲聊时间，问我有没有关注过什么开源项目，他夸我博客做的挺好看😀，问了问怎么搭的。最后终于跟我说让我过了（感谢上帝），问我有没有想问他的，就结束了。 整个面了一个多小时，那么多问题答不出时还是很紧张的。","link":"/posts/3072946492/"},{"title":"谈谈 Pyinstaller 的编译和反编译","text":"用Python写脚本，小程序可谓非常方便，但它需要有特定的python环境才能运行，因此如果你想在别的电脑上运行时就会出现许多问题，就算已经安装了Python，但版本可能相差较大，且相关的依赖库没有安装，同样不能正常运行。那有没有一种工具能把我们写的代码和依赖库以及编译环境打包到一起呢？答案是肯定的，Pyinstaller就是一款不错的工具，可以一键把你的代码打包成exe文件。下面就先来聊一聊pyinstaller的使用方法。 一、用Pyinstaller打包python代码1. 安装Pyinstaller安装过程非常简单，在命令行中运行： 1pip install pyinstaller 即可完成安装。 2. 打包代码我写了一段简单的代码作为例子，为了更清晰地演示打包过程，我将main()函数写在了单独的文件中，并将mylib.py作为一个库引入。 1234567891011# mylib.py#import timedef myfunc(): now = time.time() time_str = time.strftime(&quot;%Y-%m-%d %H:%M&quot;, time.localtime(now)) print('现在是' + time_str) print(&quot;Have a nice day!&quot;) 123456789# main.py#import mylibimport osif __name__ == &quot;__main__&quot;: mylib.myfunc() os.system('pause') 这时只需要在命令行中运行： 1pyinstaller.exe -F yourcode.py 即可。会看到一下输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445PS D:\\文档\\tmp\\test&gt; pyinstaller.exe -F main.py580 INFO: PyInstaller: 3.6582 INFO: Python: 3.7.3585 INFO: Platform: Windows-10-10.0.18362-SP0592 INFO: wrote D:\\文档\\tmp\\test\\main.spec596 INFO: UPX is not available.611 INFO: Extending PYTHONPATH with paths['D:\\\\文档\\\\tmp\\\\test', 'D:\\\\文档\\\\tmp\\\\test']612 INFO: checking Analysis614 INFO: Building Analysis because Analysis-00.toc is non existent614 INFO: Initializing module dependency graph...620 INFO: Caching module graph hooks...657 INFO: Analyzing base_library.zip ...13893 INFO: Caching module dependency graph...14161 INFO: running Analysis Analysis-00.toc14233 INFO: Adding Microsoft.Windows.Common-Controls to dependent assemblies of final executable required by d:\\programfiles\\python\\python.exe15748 INFO: Analyzing D:\\文档\\tmp\\test\\main.py15751 INFO: Processing module hooks...15752 INFO: Loading module hook &quot;hook-encodings.py&quot;...16003 INFO: Loading module hook &quot;hook-pydoc.py&quot;...16011 INFO: Loading module hook &quot;hook-xml.py&quot;...16916 INFO: Looking for ctypes DLLs16917 INFO: Analyzing run-time hooks ...16925 INFO: Looking for dynamic libraries17373 INFO: Looking for eggs17374 INFO: Using Python library d:\\programfiles\\python\\python37.dll17374 INFO: Found binding redirects:[]17377 INFO: Warnings written to D:\\文档\\tmp\\test\\build\\main\\warn-main.txt17447 INFO: Graph cross-reference written to D:\\文档\\tmp\\test\\build\\main\\xref-main.html17506 INFO: checking PYZ17507 INFO: Building PYZ because PYZ-00.toc is non existent17508 INFO: Building PYZ (ZlibArchive) D:\\文档\\tmp\\test\\build\\main\\PYZ-00.pyz18600 INFO: Building PYZ (ZlibArchive) D:\\文档\\tmp\\test\\build\\main\\PYZ-00.pyz completed successfully.18637 INFO: checking PKG18639 INFO: Building PKG because PKG-00.toc is non existent18640 INFO: Building PKG (CArchive) PKG-00.pkg22329 INFO: Building PKG (CArchive) PKG-00.pkg completed successfully.22332 INFO: Bootloader d:\\programfiles\\python\\lib\\site-packages\\PyInstaller\\bootloader\\Windows-64bit\\run.exe22334 INFO: checking EXE22335 INFO: Building EXE because EXE-00.toc is non existent22336 INFO: Building EXE from EXE-00.toc22416 INFO: Appending archive to EXE D:\\文档\\tmp\\test\\dist\\main.exe22641 INFO: Building EXE from EXE-00.toc completed successfully. 你将在当前文件夹下看到如下文件： 123456789101112131415161718D:.│ main.py│ main.spec│ mylib.py├─build│ └─main│ Analysis-00.toc│ base_library.zip│ EXE-00.toc│ main.exe.manifest│ PKG-00.pkg│ PKG-00.toc│ PYZ-00.pyz│ PYZ-00.toc│ warn-main.txt│ xref-main.html└─dist main.exe 其中dist文件夹中就是生成的exe文件。 直接双击exe文件就能正常运行了。 但这篇文章的重点并不是介绍如何使用pyinstaller。此时，我又在思考，如此简单的打包过程究竟安全吗？打包成的exe文件会不会轻而易举地被反编译？ 查阅了相关资料后发现，确实可能。 二、pyinstaller 的反编译过程1. 下载并使用pyinstxtractor解包我们第一步采用的工具是pyinstxtractor.py，可以将pyinstaller 生成的exe文件解包成pyc文件。 项目地址： https://sourceforge.net/projects/pyinstallerextractor/ 或者点此链接🔗下载 之后把这个文件复制到待解包exe同级目录下，运行如下命令： 1python pyinstxtractor.py xx.exe 运行后生成xx.exe_extracted文件夹 ，里面有一堆dll ,pyd等文件，我们需要注意的是里面有一个xxx.exe.manifest文件，xxx可能与你的exe文件名不同，但这才是它的真实名字。然后找到一个叫xxx的没有后缀名的文件，它其实就是你之前打包的那个.py文件对应的pyc文件。 我们还注意到此目录下还有一个PYZ-00.pyz_extracted文件夹，里面都是引入的依赖库，当然，我们自己写的mylib.py也在其中，它也是我们反编译的对象。 2. 反编译pyc文件找到了pyc文件，下面自然就是对它进行解密了。pyc其实是python程序执行过程中产生的缓存文件，我们直接运行python代码时也会看到。对于这种格式的反编译是比较简单的，网上有许多工具，甚至还有很多在线工具。这里为了方便，我就采用了一款在线工具。附上链接🔗 但直接将我们找到的pyc文件上传会发现无法反编译。原因是什么呢？我们用十六进制编辑器（大家网上搜就行，我这里用的是wxMEdit）打开这个文件，与之前直接运行py文件生成的pyc文件比较。 我先来看一下main.pyc的区别，左边是我们解包出来的，右边是运行生成的。 发现唯一的差别就是少了第一行16个字节（叫做 magic number 表示python的版本和编译时间），那我们把它加上是不是就能正常解析了呢？确实是这样，但没有原始pyc文件怎么办？我们再到xx.exe_extracted文件夹里找一找。会发现有一个叫struct的文件，我们给他加上后缀.pyc反编译试试。发现成功反编译出如下内容： 这就说明它的 magic number 是正确的，那我们只要把它的前16个字节复制过去不就行了？我们再来试试，成了！main.py中的内容被成功反编译出来了。 下面同理也能反编译出mylib.py等依赖库中的内容，不过值得注意的是，网上很多教程都没有提到依赖库的pyc文件缺少的字节数与主程序的不同！！！ 左：struct文件 | 中：解包出的mylib.pyc | 右：正确的pyc文件 我们发现它不是缺少了16个字节，而是中间少了4个字节！！！ 那么，我们只需要把struct头部的16个字节覆盖掉mylib.pyc的前12个字节。 改好之后再进行反编译。 反编译成功！不过中文字符被解析成了Unicode编码，可以再使用相应工具转换。 可以看到，通过pyinstaller打包的exe，还是能被较为容易地反编译的。那么有加密打包的方法吗？其实pyinstaller本身就是支持加密的，下面就来说一说如何加密打包。（这也是个天坑。。。） 三、使用pyinstaller加密打包exe其实只要在打包时加个key参数就能加密， 1pyinstaller.exe -F --key 123456 xxx.py 不过需要依赖pycrypto包，而python一般是不自带这个包的。因此需要我们手动安装。 1. 安装pycrypto包原本安装过程应该很简单，通过pip就能安装。 1pip install pycrypto 不过安装过程好像要调用VS编译器编译，这就造成了莫名其妙的问题，如果你在安装过程中没有报错，那么恭喜你，你可以跳过这部分了。 我在网上找了很多解决方法都没效，最后终于在StackOverflow上找到了一篇回答，完美解决了这个问题。原答案地址：https://stackoverflow.com/a/46921479/12954728 解决方法如下，前提是你电脑上安装了Visual studio 以我的vs2015为例 在开始菜单中找到VS文件夹，用管理员身份运行这个”兼容工具命令提示符“ 在你的VS安装目录下找到stdint.h这个文件，最好用everything搜索一下 输入set CL=-FI&quot;你的路径\\stdint.h&quot;设置环境变量 然后再执行pip install pycrypto就能成功安装了 2. 使用pyinstaller加密打包现在执行如下命令就能加密打包了。key后面为密钥可以随便输。 1pyinstaller.exe -F --key 123456 xxx.py 3. 反编译测试那么我们再来测试一下加密打包的exe还能不能被反编译。 再次执行pyinstxtractor.py 12345678910111213141516171819202122232425PS &gt; python pyinstxtractor.py .\\main-encrypt.exe import imp[*] Processing .\\main-encrypt.exe[*] Pyinstaller version: 2.1+[*] Python version: 37[*] Length of package: 5787283 bytes[*] Found 63 files in CArchive[*] Beginning extraction...please standby[+] Possible entry point: pyiboot01_bootstrap[+] Possible entry point: main[*] Found 136 files in PYZ archive[!] Error: Failed to decompress Crypto, probably encrypted. Extracting as is.[!] Error: Failed to decompress Crypto.Cipher, probably encrypted. Extracting as is.[!] Error: Failed to decompress __future__, probably encrypted. Extracting as is.[!] Error: Failed to decompress _compat_pickle, probably encrypted. Extracting as is.[!] Error: Failed to decompress argparse, probably encrypted. Extracting as is.[!] Error: Failed to decompress ast, probably encrypted. Extracting as is.[!] Error: Failed to decompress base64, probably encrypted. Extracting as is.[!] Error: Failed to decompress bdb, probably encrypted. Extracting as is.[!] Error: Failed to decompress bisect, probably encrypted. Extracting as is.[!] Error: Failed to decompress bz2, probably encrypted. Extracting as is.[!] Error: Failed to decompress calendar, probably encrypted. Extracting as is.[!] Error: Failed to decompress cmd, probably encrypted. Extracting as is.[!] Error: Failed to decompress code, probably encrypted. Extracting as is.[!] Error: Failed to decompress codeop, probably encrypted. Extracting as is. 这次下面输出了一长串Error，看来确实是被加密了。 我们再来看一看文件夹。 main-encrypt.exe_extracted文件夹里似乎没什么变化，但PYZ-00.pyz_extracted文件夹里全是加密文件，应该是无法反编译了 不过对外层文件夹中的main文件进行同样操作后依然是可以反编译出源码的。 看来这个加密只针对依赖库。 四、总结如果你不希望别人得到你的源码，建议将你程序的入口函数写在一个单独的文件里，并采用加密方式打包exe。这样的话，就算别人尝试反编译也只能得到你的入口函数。","link":"/posts/3136266189/"},{"title":"阿里校招实习二面回忆","text":"阿里二面依旧是电话面，对面电话卡了几次，最后手机打过来了。本轮面试比较意外没有代码环节。面试官是双非本科毕业的，工作了几年，大概P6,P7级别，说话比较友好，没有特别刁难我。 一开始还是先自我介绍，再着重说了下项目，问了下主要负责的工作，难点和解决方案，可能因为他是干工程的，所以没有问算法细节。 然后问了些常规的问题： 数据库ACID准则 线程、进程区别 osi7层模型（TCP传输层、HTTP是会话层） TCP三次握手 HTTP与HTTPS差别（没答上） 多线程（我不会，这就去好好学） 之后就开始闲聊，可能因为他是本科生出身，就一直在劝我，如果本科就能拿到校招offer建议直接工作（校招研究生占80%），说入职后研究生、本科生差别不大，三年工作时间大概能升到p6,p7吧。（可后面几轮还过不过得了还说不定呢。。。）","link":"/posts/1986371509/"},{"title":"静态资源加速，寻找jsdelivr的替代品","text":"jsdelivr是一个大名鼎鼎的静态资源cdn加速平台，以他免费、高速、支持github文件的特点而备受欢迎。本站也引用了大量的jsDelivr的资源，而从去年年底开始，我就发现本站访问速度异常缓慢，经查，来自cdn.jsdelivr.net的js/css等静态资源大量请求失败。全国ping下来竟然大半超时，论坛上看到说是备案被吊销了，官方推特也证实了这一点。 而截至目前（2022.2.12）还没有完全恢复，严重影响了网站的正常访问。目前看来短时间内很难恢复，只能找一些替代方法了。 步入正题，以下整理了国内高速访问的cdn平台： js/css等静态资源加速Staticfile CDN官网：https://staticfile.org/ CDN加速由七牛云提供，访问速度很快 字节跳动官网：https://cdn.bytedance.com/ 功能更丰富，支持自定义缓存时长，支持拼接js loli官网：https://cdnjs.loli.net Cloudflare国外节点，访问速度比较一般，可以应急使用 cdnjs/UNPKG这俩是国外的老牌，国内访问速度就一般了 GitHub加速jsDelivr最大的亮点就是可以加速GitHub仓库文件，因此也深受广大用户白嫖。这下老大哥倒下了可咋办？废了好大的劲终于找到一款替代品，虽然也只有国外节点，国内访问速度也不算快，但总比没有强。。。 statically官网：https://statically.io/ 支持加速GitHub、GitLab的开源仓库 链接格式： Serve file from GitHub https://cdn.statically.io/gh/:user/:repo/:tag/:file Serve file from GitLab https://cdn.statically.io/gl/:user/:repo/:tag/:file","link":"/posts/2757854163/"},{"title":"macbook初体验","text":"第一次使用macbook，从windows转移过来，已经用了几周，一句话总结：优雅是真优雅，效率是真不高。除了续航和影音体验，其他真的用着不顺手。特别是系统的窗口逻辑，感觉mac还是按照屏幕上只有一个窗口来设计的，多窗口切换非常不方便：dock栏按APP划分，对于多个浏览器窗口，只能右键图标选择。“最小化窗口”和“隐藏窗口”的逻辑也没搞懂，dock栏点击当前活动的APP还不能最小化窗口，明显是交互逻辑缺失。别说触控板手势很好用，对于双屏办公的键鼠党来说，真的不方便。初次意外还有各种反人类的设计，比如：鼠标滚轮和触控板方向强绑定，左上角关闭按钮小的离谱，状态栏不能隐藏……为了解决这些痛点，只能安装一堆软件来弥补。 下面记录下为了优化交互体验，我安装的软件： AltTab 窗口切换 MacOS 原生的窗口切换快捷键是command + tab，但是这个快捷键只能在APP之间切换，不能在APP内部切换窗口。AltTab就能带来类似windows的窗口切换体验，并且能够预览窗口内容。 uBar 任务栏 uBar可以提供类似win10的任务栏，每个打开的窗口都能平铺在任务栏上，鼠标移上去后也有预览，但这个软件是收费软件，试用14天，tb上买激活码大概50多。 Ice 状态栏折叠 一款开源软件，再也不用担心顶部的状态栏图标泛滥了。 Maccy 剪贴板 一款开源的剪贴板软件，提供类似Win+V的体验。 AutoRaise 多窗口自动激活 Mac的多窗口交互设计的稀烂，MacOS中鼠标移动到非激活到窗口上时，需要点一下激活窗口，才能跟里面的控件交互，不像windows可以直接穿透。这个软件可以自动激活窗口，不需要点一下，但在有些情况下会跟其他逻辑冲突，比如：全屏浏览器前有开了个小窗口，鼠标穿过后面的窗口时，会自动激活并把后面的窗口置顶了，导致点不到小窗口。 ScrollReverser 鼠标滚动方向 一个小工具，终于能把鼠标和触控板的方向设置拆开了。 QBlocker 屏蔽command + Q 这个软件可以屏蔽掉MacOS的command + Q快捷键，防止误操作关闭窗口。该软件太久没维护了，在新系统上有些小bug，有时会闪退。 Karabiner-Elements 按键映射Mac的caps lock键逻辑简直是一坨，中英文切换非常不灵敏，而且中文输入法直接输英文时经常会吞字。一怒之下，换了搜狗输入法，并使用Karabiner-Elements来调整按键功能，实现了短按caps lock切换中英文（不是切到ABC输入法），left shift+caps lock来切换大小写锁定。配置如下： 123456789101112131415161718192021222324252627{ &quot;manipulators&quot;: [ { &quot;description&quot;: &quot;Change caps_lock to rightshift.&quot;, &quot;from&quot;: { &quot;key_code&quot;: &quot;caps_lock&quot;, &quot;modifiers&quot;: { &quot;optional&quot;: [] } }, &quot;to_if_alone&quot;: [{ &quot;key_code&quot;: &quot;right_shift&quot; }], &quot;type&quot;: &quot;basic&quot; }, { &quot;description&quot;: &quot;Change shift+caps_lock to caps_lock.&quot;, &quot;from&quot;: { &quot;key_code&quot;: &quot;caps_lock&quot;, &quot;modifiers&quot;: { &quot;optional&quot;: [&quot;left_shift&quot;] } }, &quot;to&quot;: [ { &quot;hold_down_milliseconds&quot;: 100, &quot;key_code&quot;: &quot;caps_lock&quot; } ], &quot;type&quot;: &quot;basic&quot; } ]} 然后在搜狗输入法中将切换中英文改为右shift即可。","link":"/posts/2873710444/"}],"tags":[{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"2020实训","slug":"2020实训","link":"/tags/2020%E5%AE%9E%E8%AE%AD/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"Flume","slug":"Flume","link":"/tags/Flume/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"vps","slug":"vps","link":"/tags/vps/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"静态网站","slug":"静态网站","link":"/tags/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"},{"name":"网站日志","slug":"网站日志","link":"/tags/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"数学公式","slug":"数学公式","link":"/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"name":"latex","slug":"latex","link":"/tags/latex/"},{"name":"mathjax","slug":"mathjax","link":"/tags/mathjax/"},{"name":"访客计数","slug":"访客计数","link":"/tags/%E8%AE%BF%E5%AE%A2%E8%AE%A1%E6%95%B0/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"lingo","slug":"lingo","link":"/tags/lingo/"},{"name":"最优化问题","slug":"最优化问题","link":"/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"},{"name":"数模","slug":"数模","link":"/tags/%E6%95%B0%E6%A8%A1/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"pandas","slug":"pandas","link":"/tags/pandas/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"环境变量","slug":"环境变量","link":"/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"pyinstaller","slug":"pyinstaller","link":"/tags/pyinstaller/"},{"name":"pipenv","slug":"pipenv","link":"/tags/pipenv/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"绘图","slug":"绘图","link":"/tags/%E7%BB%98%E5%9B%BE/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"更新日志","slug":"更新日志","link":"/tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"name":"filebrowser","slug":"filebrowser","link":"/tags/filebrowser/"},{"name":"网盘","slug":"网盘","link":"/tags/%E7%BD%91%E7%9B%98/"},{"name":"交叉编译","slug":"交叉编译","link":"/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"今日头条","slug":"今日头条","link":"/tags/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"模拟登录","slug":"模拟登录","link":"/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"io","slug":"io","link":"/tags/io/"},{"name":"cloudflare","slug":"cloudflare","link":"/tags/cloudflare/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"巫师三","slug":"巫师三","link":"/tags/%E5%B7%AB%E5%B8%88%E4%B8%89/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"steam","slug":"steam","link":"/tags/steam/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"微博","slug":"微博","link":"/tags/%E5%BE%AE%E5%8D%9A/"},{"name":"hadoop","slug":"hadoop","link":"/tags/hadoop/"},{"name":"hdfs","slug":"hdfs","link":"/tags/hdfs/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"腾讯","slug":"腾讯","link":"/tags/%E8%85%BE%E8%AE%AF/"},{"name":"服务器迁移","slug":"服务器迁移","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"字节","slug":"字节","link":"/tags/%E5%AD%97%E8%8A%82/"},{"name":"阿里","slug":"阿里","link":"/tags/%E9%98%BF%E9%87%8C/"},{"name":"反编译","slug":"反编译","link":"/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"}],"categories":[{"name":"算法题解","slug":"算法题解","link":"/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"},{"name":"笔记随写","slug":"笔记随写","link":"/categories/%E7%AC%94%E8%AE%B0%E9%9A%8F%E5%86%99/"},{"name":"hexo博客","slug":"hexo博客","link":"/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"生活点滴","slug":"生活点滴","link":"/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"},{"name":"网站日志","slug":"网站日志","link":"/categories/%E7%BD%91%E7%AB%99%E6%97%A5%E5%BF%97/"}],"pages":[{"title":"404","text":"(・∀・*) 网页走丢了 404 Not Found 页面走丢了，回首页看看? 返回主页 var pageX = window.innerWidth; var pageY = window.innerHeight; var mouseY=pageX; var mouseX=pageY; $(document).mousemove(function( event ) { //verticalAxis mouseY = event.pageY; yAxis = (pageY/2-mouseY)/pageY*300; //horizontalAxis mouseX = event.pageX / -pageX; xAxis = -mouseX * 100 - 100; $('.box__ghost-eyes').css({ 'transform': 'translate('+ xAxis +'%,-'+ yAxis +'%)' }); });","link":"/404.html"},{"title":"","text":"html, body { background: #28254C; font-family: 'Ubuntu'; } * { box-sizing: border-box; } .box { width: 350px; height: 100%; max-height: 600px; min-height: 450px; background: #332F63; border-radius: 20px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 30px 50px; } .box .box__ghost { padding: 15px 25px 25px; position: absolute; left: 50%; top: 30%; transform: translate(-50%, -30%); } .box .box__ghost .symbol:nth-child(1) { opacity: .2; animation: shine 4s ease-in-out 3s infinite; } .box .box__ghost .symbol:nth-child(1):before, .box .box__ghost .symbol:nth-child(1):after { content: ''; width: 12px; height: 4px; background: #fff; position: absolute; border-radius: 5px; bottom: 65px; left: 0; } .box .box__ghost .symbol:nth-child(1):before { transform: rotate(45deg); } .box .box__ghost .symbol:nth-child(1):after { transform: rotate(-45deg); } .box .box__ghost .symbol:nth-child(2) { position: absolute; left: -5px; top: 30px; height: 18px; width: 18px; border: 4px solid; border-radius: 50%; border-color: #fff; opacity: .2; animation: shine 4s ease-in-out 1.3s infinite; } .box .box__ghost .symbol:nth-child(3) { opacity: .2; animation: shine 3s ease-in-out .5s infinite; } .box .box__ghost .symbol:nth-child(3):before, .box .box__ghost .symbol:nth-child(3):after { content: ''; width: 12px; height: 4px; background: #fff; position: absolute; border-radius: 5px; top: 5px; left: 40px; } .box .box__ghost .symbol:nth-child(3):before { transform: rotate(90deg); } .box .box__ghost .symbol:nth-child(3):after { transform: rotate(180deg); } .box .box__ghost .symbol:nth-child(4) { opacity: .2; animation: shine 6s ease-in-out 1.6s infinite; } .box .box__ghost .symbol:nth-child(4):before, .box .box__ghost .symbol:nth-child(4):after { content: ''; width: 15px; height: 4px; background: #fff; position: absolute; border-radius: 5px; top: 10px; right: 30px; } .box .box__ghost .symbol:nth-child(4):before { transform: rotate(45deg); } .box .box__ghost .symbol:nth-child(4):after { transform: rotate(-45deg); } .box .box__ghost .symbol:nth-child(5) { position: absolute; right: 5px; top: 40px; height: 12px; width: 12px; border: 3px solid; border-radius: 50%; border-color: #fff; opacity: .2; animation: shine 1.7s ease-in-out 7s infinite; } .box .box__ghost .symbol:nth-child(6) { opacity: .2; animation: shine 2s ease-in-out 6s infinite; } .box .box__ghost .symbol:nth-child(6):before, .box .box__ghost .symbol:nth-child(6):after { content: ''; width: 15px; height: 4px; background: #fff; position: absolute; border-radius: 5px; bottom: 65px; right: -5px; } .box .box__ghost .symbol:nth-child(6):before { transform: rotate(90deg); } .box .box__ghost .symbol:nth-child(6):after { transform: rotate(180deg); } .box .box__ghost .box__ghost-container { background: #fff; width: 100px; height: 100px; border-radius: 100px 100px 0 0; position: relative; margin: 0 auto; animation: upndown 3s ease-in-out infinite; } .box .box__ghost .box__ghost-container .box__ghost-eyes { position: absolute; left: 50%; top: 45%; height: 12px; width: 70px; } .box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-left { width: 12px; height: 12px; background: #332F63; border-radius: 50%; margin: 0 10px; position: absolute; left: 0; } .box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-right { width: 12px; height: 12px; background: #332F63; border-radius: 50%; margin: 0 10px; position: absolute; right: 0; } .box .box__ghost .box__ghost-container .box__ghost-bottom { display: flex; position: absolute; top: 100%; left: 0; right: 0; } .box .box__ghost .box__ghost-container .box__ghost-bottom div { flex-grow: 1; position: relative; top: -10px; height: 20px; border-radius: 100%; background-color: #fff; } .box .box__ghost .box__ghost-container .box__ghost-bottom div:nth-child(2n) { top: -12px; margin: 0 -0px; border-top: 15px solid #332F63; background: transparent; } .box .box__ghost .box__ghost-shadow { height: 20px; box-shadow: 0 50px 15px 5px #3B3769; border-radius: 50%; margin: 0 auto; animation: smallnbig 3s ease-in-out infinite; } .box .box__description { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); } .box .box__description .box__description-container { color: #fff; text-align: center; width: 200px; font-size: 16px; margin: 0 auto; } .box .box__description .box__description-container .box__description-title { font-size: 24px; letter-spacing: .5px; } .box .box__description .box__description-container .box__description-text { color: #8C8AA7; line-height: 20px; margin-top: 20px; } .box .box__description .box__button { display: block; position: relative; background: #FF5E65; border: 1px solid transparent; border-radius: 50px; height: 50px; text-align: center; text-decoration: none; color: #fff; line-height: 50px; font-size: 18px; padding: 0 70px; white-space: nowrap; margin-top: 25px; transition: background .5s ease; overflow: hidden; } .box .box__description .box__button:before { content: ''; position: absolute; width: 20px; height: 100px; background: #fff; bottom: -25px; left: 0; border: 2px solid #fff; transform: translateX(-50px) rotate(45deg); transition: transform .5s ease; } .box .box__description .box__button:hover { background: transparent; border-color: #fff; } .box .box__description .box__button:hover:before { transform: translateX(250px) rotate(45deg); } @keyframes upndown { 0% { transform: translateY(5px); } 50% { transform: translateY(15px); } 100% { transform: translateY(5px); } } @keyframes smallnbig { 0% { width: 90px; } 50% { width: 100px; } 100% { width: 90px; } } @keyframes shine { 0% { opacity: .2; } 25% { opacity: .1; } 50% { opacity: .2; } 100% { opacity: .2; } }","link":"/404/404.css"},{"title":"About me - Zhouyang Lu","text":"Hi there! 👋 I’m a master’s student at the School of Computer Science, Fudan University, with a passion for Human-Computer Interaction. When I’m not immersed in research, you’ll find me hiking trails or capturing moments through photography. Feel free to email me or directly drop a message below! 🤗","link":"/about/index.html"},{"title":"API工具箱","text":"本页收录了本站自建API，欢迎使用！ bing每日图片获取 2022/1/16上线 https://api.luzy.top/bingimg GitHub加速 2023/12/1上线 https://gh.luzy.top OpenAI加速 2024/3/1上线 https://\\*\\*\\*.\\*\\*\\*.\\*\\*\\* To be continued…","link":"/api_page/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"🙏友链位招租欢迎各位小伙伴来交换友链~ 直接在评论区留言即可 留言格式 名称：江风引雨の小站地址：https://blog.luzy.top头像：https://www.gravatar.com/avatar/fe3373de9647b0c702831909a0e98db0?s=128介绍：立身浮华之世，奏响天籁之声 一起交个朋友呗~😁🤝","link":"/links/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}